# PowerBy 工作流完整指南
**Complete Guide to PowerBy Workflow**

**文档版本**: v3.5.0
**创建日期**: 2025-12-18
**最后更新**: 2025-12-24
**维护者**: PowerBy Team
**适用范围**: 专注MVP的产品开发生命周期管理框架
**更新说明**:
- v3.1.0 - 优化P1+P2流程，融合为"需求定稿制"
- v3.2.0 - 新增MCS协议（最小上下文集），物理隔离噪声信息，降低AI Token成本
- v3.2.1 - 修正MCS协议，强调constitution.md为最高宪法，所有阶段必须严格遵循
- v3.2.2 - 优化MCS协议，从"严禁读取"改为"优先级参考"，建立核心参考文档和次要参考文档体系
- v3.3.0 - MVP精简优化：移除非功能性属性扫描、简化发布流程、精简元数据追踪
- v3.4.0 - GitHub分支管理自动化：集成powerby-github-branch技能，实现P0-P8自动化分支管理
- v3.5.0 - 迭代思维增强：融入"充分了解、严格遵循、优先复用"理念，统一产品、研发和架构技能

---

## 📑 目录

1. [概述与愿景](#1-概述与愿景)
2. [核心理念与原则](#2-核心理念与原则)
3. [MVP生命周期概览](#3-mvp生命周期概览)
4. [阶段详细说明](#4-阶段详细说明)
   - [P0-P1: MVP产品定义](#p0-p1-mvp产品定义)
   - [P3-P4: 架构设计阶段](#p3-p4-架构设计阶段)
   - [P5-P6: 工程实现阶段](#p5-p6-工程实现阶段)
   - [P7: 代码审查阶段](#p7-代码审查阶段)
5. [技能协作模型](#5-技能协作模型)
6. [文档管理体系](#6-文档管理体系)
7. [质量门禁机制](#7-质量门禁机制)
8. [迭代管理规范](#8-迭代管理规范)
9. [受阻处理协议](#9-受阻处理协议)
10. [最佳实践](#10-最佳实践)
11. [常见问题](#11-常见问题)
12. [附录](#12-附录)

---

## 1. 概述与愿景

### 1.1 什么是PowerBy

PowerBy是一个**专注于MVP的结构化产品开发生命周期管理框架**，旨在通过AI协作实现从需求到可运行产品的快速闭环。它将MVP开发过程分解为7个核心阶段（P0-P1, P3-P7），遵循奥卡姆剃刀原则，专注于核心价值实现，避免过度工程化。

### 1.2 核心价值

- **MVP专注**: 专注于最小可行产品的核心价值实现，避免过度设计
- **奥卡姆剃刀**: 如无必要，勿增实体 - 精简非核心流程和文档
- **快速闭环**: 从需求到可运行产品的最短路径
- **可追溯**: 每个决策都有清晰的依据和文档记录
- **AI友好**: 专为AI协作设计的工作流程
- **务实导向**: 分离开发实现流程与运维流程

### 1.3 设计目标

1. **消除模糊性**: 每个阶段都有明确的输入、输出和验收标准
2. **建立共识**: 通过结构化的协作建立团队共识
3. **提高效率**: 减少返工和沟通成本
4. **保证质量**: 通过多层次的审查确保交付质量
5. **知识沉淀**: 形成完整的项目知识库

---

## 2. 核心理念与原则

### 2.1 核心理念

PowerBy框架建立在以下核心理念之上：

#### 🎯 零假设原则 (Zero-Assumption Principle)
**绝不猜测用户的模糊意图**。当指令不明确或缺少关键信息时，首要职责是提出具体问题以澄清需求，而不是基于假设进行工作。

**应用**:
- 在任何阶段遇到模糊需求时，立即停止并请求澄清
- 假设会导致错误的方向，必须通过结构化的问题消除不确定性

#### 🚀 小步提交原则 (Small Steps Principle)
**优于"大爆炸"式开发**。代码应频繁提交，每次提交都需确保可编译且通过测试。

**应用**:
- 将大任务分解为小的、可验证的步骤
- 每个迭代都有明确的、可测试的产出
- 避免长时间的开发周期导致的风险累积

#### 🔍 借鉴现有原则 (Learn from Existing)
**借鉴现有代码，而后创造**。在动手实现前，先研究项目中的既有模式，做好规划。

**应用**:
- 分析项目中已有的模式和最佳实践
- 从成功的案例中学习
- 避免重复发明轮子

#### 🎨 务实原则 (Pragmatism Over Dogma)
**拥抱务实，而非固守教条**。灵活适应项目现实，选择最合适的解决方案。

**应用**:
- 根据项目特点选择合适的工具和方法
- 避免过度工程化和过早优化
- 关注实际的业务价值

#### 💎 意图清晰原则 (Intent Clarity)
**意图清晰，优于炫技代码**。编写"无聊"且一目了然的代码。

**应用**:
- 代码和文档应该易于理解
- 优先选择简单直接的解决方案
- 避免不必要的复杂性和抽象

#### 🔄 迭代思维与复用优先原则 (Iterative Thinking & Reuse-First) ⭐ **新增**
**来自项目宪法的核心原则**。在开始任何新工作之前，必须充分了解、严格遵循、优先复用已有的项目架构、规范和服务。

**应用**:
- **持续演进**: 项目是迭代演进的，不是一次性完成的。每个功能都应在现有基础上增量改进
- **充分了解**: 在开始任何新工作之前，必须充分了解现有项目架构、技术栈和设计模式
- **严格遵循**: 识别并严格遵循项目已有的编码规范、文档规范和最佳实践
- **优先复用**: 系统性识别可复用的现有服务、组件、工具类和业务逻辑，优先选择复用路径
- **增量扩展**: 优先通过增量扩展现有能力来满足新需求，而非创建孤立的模块

### 2.2 设计哲学

#### SOLID原则
- **单一职责**: 每个模块只做一件事
- **开放封闭**: 对扩展开放，对修改封闭
- **里氏替换**: 子类可以替换父类
- **接口隔离**: 依赖最小化的接口
- **依赖倒置**: 依赖抽象而非具体实现

#### DRY原则 (Don't Repeat Yourself)
- 消除重复代码
- 将通用逻辑抽象为可复用的组件
- 保持代码的单一来源

#### KISS原则 (Keep It Simple)
- 选择最简单的解决方案
- 避免不必要的复杂性
- 奥卡姆剃刀：如无必要，勿增实体

#### Mixin思维 (Mixin Thinking)
- 增量式协作和贡献
- 每个决策都是可回滚的Mixin单元
- 技术文档与产品文档融合
- 跨角色协作桥梁

### 2.3 协作原则

#### 轮询协作模型
采用**回合制协作模式**：
1. **第一回合致意**: 明确角色和职责
2. **后续回合循环**: 持续迭代和优化
3. **最终交付**: 明确的完成标志

#### 顾问式流程
作为**顾问和思维伙伴**，而不是决策者：
- 提供专业的分析和建议
- 等待用户的最终指令
- 基于用户决策进行下一步

#### 3次尝试原则
**针对同一问题，最多尝试3次。如果依然无法解决，立刻停止。**

四步处理流程：
1. **记录失败过程**: 详细记录尝试的方法、错误和原因
2. **研究替代方案**: 寻找2-3个类似实现案例
3. **反思基本问题**: 思考抽象层级、问题拆分、整体方案
4. **尝试不同角度**: 技术栈、架构模式、简化策略

---

## 3. MVP生命周期概览

### 3.1 MVP生命周期图表

```mermaid
graph TD
    P0[P0: 项目初始化] --> P1[P1: 需求定义+澄清]
    P1 --> P3[P3: 技术调研]
    P3 --> P4[P4: 架构设计]
    P4 --> P5[P5: 任务规划]
    P5 --> P6[P6: 开发实现]
    P6 --> P7[P7: 代码审查]

    Gate0[Gate 0: 项目可行性] --> P0
    Gate1[Gate 1: 需求定稿] --> P1
    Gate3[Gate 3: 技术可行性] --> P3
    Gate4[Gate 4: 架构设计清晰性] --> P4
    Gate5[Gate 5: 任务计划完整性] --> P5
    Gate6[Gate 6: 实现完整性] --> P6
    Gate7[Gate 7: 代码审查完整性] --> P7
```

**说明**: 专注于MVP核心流程，移除了P2非功能性属性扫描和P8运维交付流程

### 3.2 MVP阶段概览表

| 阶段 | 名称 | 主要职责 | 核心技能 | 关键产出 | 质量门禁 |
|------|------|----------|----------|----------|----------|
| P0 | 项目初始化 | 明确MVP范围和目标 | powerby-product | 项目章程 | Gate 0 |
| P1 | 需求定义+澄清 ⭐ | 结构化PRD、功能点，专注MVP核心价值 | powerby-product | prd.md, function-points.md, clarifications.md | Gate 1 |
| P3 | 技术调研 | MVP技术可行性评估 | powerby-architect | technical-research.md | Gate 3 |
| P4 | 架构设计 | 最小可行架构设计 | powerby-architect | architecture.md | Gate 4 |
| P5 | 任务规划 | MVP开发任务分解 | powerby-engineer | tasks.md | Gate 5 |
| P6 | 开发实现 | MVP代码实现和测试 | powerby-engineer | implementation-report.md | Gate 6 |
| P7 | 代码审查 | MVP代码质量审查 | powerby-code-review | code-review-report.md | Gate 7 |

⭐ **注**: P1阶段融合了需求定义与澄清，专注MVP核心价值，避免过度设计

### 3.3 阶段流转规则

1. **MVP专注**: 严格按照P0→P1→P3→...→P7的MVP核心流程执行
2. **质量门禁**: 每个阶段必须通过相应的质量门禁才能进入下一阶段
3. **迭代性**: 支持在任一阶段进行迭代优化
4. **回滚性**: 未通过门禁可以返回上一阶段或相关阶段
5. **运维分离**: P8运维交付流程独立于MVP开发流程

---

## 4. 阶段详细说明

## P0-P1: MVP产品定义

### P0: 项目初始化 (Project Initialization)

#### 🎯 阶段目标
明确项目的范围、目标、成功标准和初始约束，为整个项目奠定基础。

#### 📥 输入条件
- 项目初步想法或需求描述
- 项目发起人的初步说明

#### 🛠️ 执行步骤

**Step 1: 项目范围界定**
- 明确项目要解决的核心问题
- 定义项目的边界（做什么、不做什么）
- 识别关键干系人

**Step 2: 目标设定**
- 设定SMART目标（具体、可衡量、可达成、相关、有时限）
- 定义成功标准
- 识别关键里程碑

**Step 3: 约束识别**
- 时间约束
- 资源约束
- 技术约束
- 合规约束

#### 📄 产出文档
- **项目章程** (project-charter.md)
  - 项目概述
  - 核心目标
  - 成功标准
  - 关键里程碑
  - 约束条件

#### ✅ 验收标准 (Gate 0)
- [ ] 项目范围明确且有文档记录
- [ ] 成功标准可衡量且达成一致
- [ ] 关键里程碑已识别
- [ ] 项目章程获得干系人确认

#### 🎭 执行角色
**powerby-product** (产品经理)

#### 💡 最佳实践
- 保持项目章程简洁明了（1-2页）
- 定期回顾和更新项目章程
- 确保所有干系人对项目范围有一致理解

---

### P1: 需求定义+澄清 (Requirement Definition + Clarification)

#### 🎯 阶段目标
将MVP核心想法转化为结构化的产品需求文档（PRD），包括完整的功能点清单，并通过融合澄清过程消除所有模糊点。**专注MVP核心价值，避免过度工程化**。

#### 📥 输入条件
- ✅ P0已完成
- ✅ 项目章程已通过Gate 0
- ✅ 核心需求已明确

#### 🛠️ 执行步骤

**Step 1: 需求收集与分析**
- 从项目章程中提取核心需求
- 分析用户画像和使用场景
- 识别功能优先级（P0/P1/P2）

**Step 1.5: 现有能力分析 ⭐ 新增**
- **现有功能盘点**: 读取现有PRD文档，了解已实现功能，分析现有API和服务能力
- **复用可能性评估**: 评估新需求与现有能力的重叠度，识别可直接复用或可扩展的功能
- **一致性检查**: 检查新功能与现有功能的风格一致性，确保交互模式和用户体验连贯

**Step 2: 功能点结构化**
采用**3部分模板结构**：
1. **需求分析**: 明确需求来源、用户价值、业务目标
2. **方案设计**: 提出具体的功能设计和实现思路
3. **实施路径**: 定义MVP路径和迭代计划

**Step 3: 功能点清单生成**
为每个P0功能点创建完整的功能点定义，包含8要素：
1. **需求来源**: 来自哪个用户或业务需求
2. **功能描述**: 清晰的功能说明
3. **用户输入**: 用户如何与功能交互
4. **系统输出**: 功能的预期输出
5. **关键约束**: 技术和业务约束
6. **验收标准**: 功能完成的判定标准
7. **依赖关系**: 与其他功能的关系
8. **预估工时**: 开发工作量估算

**Step 4: 同步澄清过程 ⭐**
- **AI自检**: 在生成PRD过程中同步识别模糊点，列出[AI待澄清事项清单]
- **交互式澄清**: 向用户展示澄清事项，获取回复并实时更新文档
- **澄清记录**: 将澄清过程和结果记录到clarifications.md
- **最终确认**: 确保PRD、功能点清单和澄清记录无矛盾

#### 📄 产出文档
- **产品需求文档** (prd.md)
  - 项目概述
  - 用户画像
  - 核心功能
  - 非功能需求
  - 约束条件

- **功能点清单** (function-points.md)
  - P0功能点列表（必须实现）
  - P1功能点列表（重要但不紧急）
  - P2功能点列表（未来规划）
  - 每个功能点的8要素定义

- **需求澄清记录** (clarifications.md)
  - 澄清问题列表
  - 澄清过程记录
  - 最终确认的需求
  - 变更记录

#### ✅ 验收标准 (Gate 1 - 需求定稿)
- [ ] **完整性**: PRD结构完整，所有P0功能点已定义且包含8要素
- [ ] **无歧义性**: 文档中无[TBD]或模糊描述
- [ ] **自洽性**: 功能点清单与业务逻辑无矛盾
- [ ] **澄清记录**: clarifications.md完整记录所有澄清历史
- [ ] **功能优先级**: P0/P1/P2优先级已明确且有依据
- [ ] **PRD一致性**: PRD与项目章程一致

#### 🎭 执行角色
**powerby-product** (产品经理)

#### 💡 最佳实践
- 采用轮询协作模型：回合致意→回合循环→最终交付
- **同步推理**: AI在生成PRD的同时发现并澄清模糊点
- **减少轮次**: 避免"P1完成→等待确认→进入P2"的冗余循环
- 每个功能点都要有清晰的验收标准
- 功能点清单是后续所有阶段的审查基准

---

## P3-P4: 架构设计阶段

### P3: 技术调研 (Technical Research)

#### 🎯 阶段目标
深度技术方案研究，评估技术可行性，为架构设计提供技术选型依据。

#### 📥 输入条件
- ✅ P1已完成
- ✅ prd.md、clarifications.md、function-points.md已通过Gate 1
- ✅ 产品需求已明确

#### 🛠️ 执行步骤

**Step 1: 需求解读与目标对齐**
- 深入分析PRD中的功能点清单
- 提炼核心业务目标和关键用户流程
- 向用户寻求确认

**Step 2: 技术调研分析**
针对每个核心功能点，进行深度技术调研：

**调研维度**：
1. **技术栈选型**: 前端、后端、数据库、缓存、中间件
2. **架构模式**: 单体/微服务/事件驱动/函数式等
3. **关键技术**: 第三方服务、SDK、API集成
4. **性能与扩展**: 并发处理、横向扩展、缓存策略
5. **安全与合规**: 认证授权、数据加密、合规要求

**Step 3: 技术决策点识别**
- 识别关键技术决策点
- 提供至少2种可行方案
- 进行结构化评估（优点、缺点、适用场景）

#### 📄 产出文档
- **技术调研报告** (technical-research.md)
  - 核心技术选型
  - 关键技术决策点
  - 方案评估与推荐
  - 技术风险分析

#### ✅ 验收标准 (Gate 3)
- [ ] 所有P0功能的技术可行性已评估
- [ ] 核心技术选型已完成决策（至少1个备选方案）
- [ ] 关键技术风险已识别并有缓解措施
- [ ] 技术调研报告结构完整

#### 🎭 执行角色
**powerby-architect** (系统架构师)

#### 💡 最佳实践
- 保持技术选型与MVP目标一致
- 优先考虑成熟稳定的技术
- 记录所有技术决策的依据

---

### P4: 架构设计 (Architectural Design)

#### 🎯 阶段目标
将已调研的技术方案转化为清晰、可执行的技术架构设计。

#### 📥 输入条件
- ✅ P3已完成
- ✅ technical-research.md已通过Gate 3
- ✅ 技术选型已确认

#### 🛠️ 执行步骤

**遵循4阶段强制工作流程**：

##### 阶段一：需求解读与目标对齐
- 深入分析PRD中的功能点清单
- 提炼核心业务目标和关键用户流程
- **必须停止并向用户请求确认**

##### 阶段二：架构设计与可视化
- 生成Mermaid架构图（C4 Component图、系统架构图等）
- 提供架构图说明（概念解读、组件职责）
- **组件与需求映射**（关键的可追溯性保证）
- 交互说明

##### 阶段三：关键决策点与方案评估
- 识别2-3个最关键的架构决策点
- 提供至少2种可行方案的结构化评估
- 明确给出推荐方案和理由

##### 阶段四：寻求最终决策与交付
- 汇总所有分析
- 明确请求用户做出最终选择
- 生成architecture.md文档

#### 📄 产出文档
- **技术架构设计文档** (architecture.md)
  - 需求概述
  - 核心技术选型
  - 核心架构设计（Mermaid图）
  - 组件与需求映射
  - 关键技术决策
  - 技术栈清单
  - 扩展性考虑
  - 非功能需求

#### ✅ 验收标准 (Gate 4)
- [ ] 架构图清晰表达了系统结构
- [ ] 每个组件的职责明确且有需求映射
- [ ] 所有关键技术决策已完成并记录
- [ ] 架构设计符合PRD要求
- [ ] 非功能需求（性能、安全等）已考虑

#### 🎭 执行角色
**powerby-architect** (系统架构师)

#### 💡 最佳实践
- 架构图应该清晰易懂
- 组件与需求映射是强制要求
- 关键决策点要有充分的理由支撑

---

## P5-P6: 工程实现阶段

### P5: 任务规划 (Task Planning)

#### 🎯 阶段目标
基于架构设计，将功能需求分解为可执行的开发任务，并为每个任务定义清晰的验收标准。

#### 📥 输入条件
- ✅ P4已完成
- ✅ architecture.md已通过Gate 4
- ✅ 技术架构已确认

#### 🛠️ 执行步骤

**Step 1: 任务分解**
- 基于architecture.md中的组件划分
- 将功能点分解为具体的开发任务
- 确保每个任务都有明确的产出

**Step 1.3: 现有代码分析 ⭐ 新增**
- **代码库扫描**: 扫描src/目录，了解项目结构和模块组织，识别现有服务、组件和工具类
- **复用能力评估**: 识别可直接复用的代码组件，识别可扩展的现有实现，评估复用的适配成本
- **规范识别**: 识别项目编码规范、命名约定、测试规范和文档标准

**Step 2: 哲学对齐分析**
在技术设计阶段融入**5大设计哲学评估**：
1. **SOLID原则**: 评估代码是否符合单一职责、开放封闭等
2. **KISS原则**: 评估设计是否足够简单
3. **DRY原则**: 评估是否存在重复代码
4. **最小影响面**: 评估变更的影响范围
5. **最小惊讶原则**: 评估设计是否符合用户期望

**Step 3: 任务定义**
为每个任务定义：
- 任务ID和名称
- 所属组件
- 关联的功能点
- 详细描述
- 验收标准
- 预估工时
- 依赖关系

#### 📄 产出文档
- **开发任务清单** (tasks.md)
  - 任务列表
  - 任务详情
  - 依赖关系图
  - 优先级排序
  - 迭代计划

#### ✅ 验收标准 (Gate 5)
- [ ] 所有P0功能点已分解为具体任务
- [ ] 每个任务都有明确的验收标准
- [ ] 任务依赖关系清晰
- [ ] 哲学对齐分析已完成

#### 🎭 执行角色
**powerby-engineer** (软件工程师)

#### 💡 最佳实践
- 任务粒度要适中（1-3天可完成）
- 验收标准要可测试
- 考虑并行开发的可能性

---

### P6: 开发实现 (Development Implementation)

#### 🎯 阶段目标
基于任务规划，完成代码实现、测试和文档编写，形成可交付的实现成果。

#### 📥 输入条件
- ✅ P5已完成
- ✅ tasks.md已通过Gate 5
- ✅ 开发任务已明确

#### 🛠️ 执行步骤

**Step 1: 实现策略制定**
- 根据tasks.md中的任务清单
- 制定实现顺序和策略
- 识别技术风险和缓解措施

**Step 2: 代码实现**
遵循**TDD（测试驱动开发）**流程：
1. **理解**: 研究代码库中的现有模式
2. **测试**: 编写失败的测试（红灯）
3. **实现**: 编写最精简的代码，让测试通过（绿灯）
4. **重构**: 在测试的保护下，清理和优化代码
5. **提交**: 撰写清晰的提交信息，并关联到开发计划

**Step 3: 测试验证**
- 单元测试
- 集成测试
- 端到端测试
- 性能测试

**Step 4: 文档编写**
- API文档
- 代码注释
- 部署文档
- 用户指南

#### 📄 产出文档
- **实现报告** (implementation-report.md)
  - 实现概述
  - 任务完成情况
  - 测试覆盖率
  - 技术决策记录
  - 性能指标
  - 已知问题和解决方案

#### ✅ 验收标准 (Gate 6)
- [ ] 所有P0任务已完成
- [ ] 代码质量符合项目标准
- [ ] 测试覆盖率达标
- [ ] 实现报告完整且准确

#### 🎭 执行角色
**powerby-engineer** (软件工程师)

#### 💡 最佳实践
- 保持小步提交的习惯
- 每个提交都要有清晰的说明
- 及时更新任务状态

---

## P7: 代码审查阶段

### P7: 代码审查 (Code Review)

#### 🎯 阶段目标
对MVP代码实现进行全面审查，确保代码质量、流程闭环和文档一致性，**完成MVP开发流程**。运维交付流程独立于开发流程。

#### 📥 输入条件
- ✅ P6已完成
- ✅ implementation-report.md已通过Gate 6
- ✅ 代码实现已完成并提交PR

#### 🛠️ 执行步骤

**Step 1: 上下文信息收集**
必须接收的基准文档：
1. **产品需求文档**（prd.md）：定义功能点
2. **功能点清单**（function-points.md）：结构化的功能点列表
3. **架构设计文档**（architecture.md）：定义组件职责
4. **任务计划文档**（tasks.md）：定义开发任务
5. **实现报告**（implementation-report.md）：开发成果
6. **合并请求**（PR）：代码变更集

**Step 2: 执行审查清单**
按照**5大类审计清单**逐项检查：

##### 1. 一致性与范围审计
- 功能点一致性验证
- 任务一致性验证
- 架构一致性验证
- 需求一致性验证
- 范围控制验证

##### 2. 实现完整性与真实性审计
- 避免假实现（硬编码、空函数、TODO等）
- 确保所有调用都有实现
- 业务逻辑基于真实数据流

##### 3. 设计哲学与代码质量审计
- SOLID原则
- KISS原则
- DRY原则
- 代码可读性
- 最小影响面

##### 4. 测试与健壮性审计
- 自动化测试充分性
- 错误处理恰当性
- 安全性检查

##### 5. 提交质量审计
- 提交信息清晰性
- 小步提交
- 关联任务ID

**Step 3: 生成审计报告**
使用**7部分结构化审计报告**：
1. 最终结论（APPROVED/CHANGES REQUESTED）
2. 总体评价
3. 功能实现与验收方案
4. 一致性与可追溯性验证
5. 详细修改建议
6. 优秀实践亮点
7. 审计摘要统计

#### 📄 产出文档
- **代码审计报告** (code-review-report.md)
  - 审查结果
  - 功能点完成情况
  - 详细修改建议
  - 审计统计

#### ✅ 验收标准 (Gate 7)
- [ ] 所有5大类审计项已完成检查
- [ ] 功能点一致性验证已完成
- [ ] 所有P0功能点的验收标准都已满足
- [ ] 最终结论明确（APPROVED或CHANGES REQUESTED）
- [ ] 可追溯性矩阵验证完成

#### 🎭 执行角色
**powerby-code-review** (首席工程师 & 流程守护者)

#### 💡 最佳实践
- 严格对照基准文档进行审查
- 保持客观、公正、有据可依
- 提供可执行的功能验收方案

---

### P8: 运维交付流程 (可选) 🚧

> **说明**: P8属于运维流程，独立于MVP开发流程。在MVP验证成功后再进行。

#### 🎯 阶段目标
完成运维交付，包括部署准备、监控配置和项目总结，确保MVP可以稳定运行。

#### 📥 输入条件
- ✅ P7已完成
- ✅ code-review-report.md已通过Gate 7
- ✅ MVP代码已通过审查并合并到主干

#### 🛠️ 运维流程 (DevOps职责)

**Step 1: 部署准备**
- 配置CI/CD流水线
- 准备部署脚本
- 设置环境变量

**Step 2: 监控与日志**
- 配置APM监控
- 设置日志收集
- 配置告警规则

**Step 3: 发布文档**
- 编写Release Notes
- 创建部署指南
- 准备回滚方案

#### 📄 产出文档
- **运维交付报告** (operations-delivery.md)
  - 部署清单
  - 监控配置
  - 运维指南

#### ✅ 运维验收标准
- [ ] 部署流程已验证
- [ ] 监控和日志已配置
- [ ] 运维文档完整

#### 🎭 执行角色
**DevOps团队** (运维工程师)

---

## 5. 技能协作模型

### 5.1 技能角色定义

| 技能名称 | 核心角色 | 主要职责 | 协作阶段 |
|----------|----------|----------|----------|
| powerby-product | 产品经理 | 需求定义+澄清、产品规划 | P0-P1 |
| powerby-architect | 系统架构师 | 技术调研、架构设计 | P3-P4 |
| powerby-engineer | 软件工程师 | 任务规划、开发实现 | P5-P6 |
| powerby-code-review | 首席工程师 | 代码审查、MVP交付 | P7 |
| powerby-fullstack ⭐ | 全栈工程师 | 快速处理临时小需求 | P0-P5 |
| DevOps团队 | 运维工程师 | 运维交付流程 | P8 (可选) |

### 5.2 协作流程

```mermaid
sequenceDiagram
    participant U as 用户
    participant P as powerby-product
    participant A as powerby-architect
    participant E as powerby-engineer
    participant R as powerby-code-review
    participant D as DevOps

    U->>P: 启动项目
    P->>P: P0-P1: MVP产品定义
    P->>A: 交付PRD和功能点
    A->>A: P3-P4: 架构设计
    A->>E: 交付架构文档
    E->>E: P5-P6: 工程实现
    E->>R: 交付实现成果
    R->>R: P7: 代码审查
    R->>U: MVP完成
    Note over U,D: MVP验证成功后进行运维交付
    U->>D: 启动运维交付
    D->>D: P8: 运维交付
    D->>U: 运维交付完成
```

### 5.3 协作原则

1. **Mixin思维**: 每个技能的输出都是对前一阶段成果的增量补充
2. **可追溯性**: 保持从需求到实现的完整追溯链
3. **质量门禁**: 每个阶段的输出都要通过质量门禁
4. **文档驱动**: 所有决策都要有文档记录

---

## 6. 文档管理体系

### 6.1 文档层级结构

```
项目根目录/
├── .powerby/                 # 项目元数据
│   ├── project.json         # 项目基本信息
│   └── iterations.json      # 迭代状态追踪
├── docs/                     # 项目文档
│   ├── constitution.md       # 项目章程
│   └── iterations/           # 迭代文档
│       └── {id}-{name}/      # 具体迭代
│           ├── prd.md        # 产品需求文档
│           ├── clarifications.md # 需求澄清
│           ├── function-points.md # 功能点清单
│           ├── technical-research.md # 技术调研
│           ├── architecture.md # 架构设计
│           ├── tasks.md      # 任务清单
│           ├── implementation-report.md # 实现报告
│           ├── code-review-report.md # 审查报告
│           └── delivery-report.md # 交付报告
```

### 6.2 核心文档说明

#### PRD (Product Requirements Document)
- **路径**: `docs/iterations/{id}-{name}/prd.md`
- **内容**: 产品概述、用户画像、核心功能、非功能需求
- **维护者**: powerby-product
- **更新频率**: P1阶段创建和更新（融合澄清过程）

#### Function Points (功能点清单)
- **路径**: `docs/iterations/{id}-{name}/function-points.md`
- **内容**: 结构化的功能点列表，每个功能点包含8要素
- **维护者**: powerby-product
- **更新频率**: P1阶段创建，后续阶段参考

#### Architecture (架构设计)
- **路径**: `docs/iterations/{id}-{name}/architecture.md`
- **内容**: 技术架构图、组件职责、决策记录
- **维护者**: powerby-architect
- **更新频率**: P4阶段创建，P5阶段参考

#### Tasks (任务清单)
- **路径**: `docs/iterations/{id}-{name}/tasks.md`
- **内容**: 开发任务列表、依赖关系、验收标准
- **维护者**: powerby-engineer
- **更新频率**: P5阶段创建，P6阶段更新

#### Implementation Report (实现报告)
- **路径**: `docs/iterations/{id}-{name}/implementation-report.md`
- **内容**: 实现成果、测试结果、技术决策
- **维护者**: powerby-engineer
- **更新频率**: P6阶段创建

#### Code Review Report (审查报告)
- **路径**: `docs/iterations/{id}-{name}/code-review-report.md`
- **内容**: 审查结果、修改建议、审计统计
- **维护者**: powerby-code-review
- **更新频率**: P7阶段创建

#### Delivery Report (交付报告)
- **路径**: `docs/iterations/{id}-{name}/delivery-report.md`
- **内容**: 项目总结、交付清单、经验教训
- **维护者**: powerby-code-review
- **更新频率**: P8阶段创建

### 6.3 文档编写规范

#### Markdown规范
- 使用标准Markdown语法
- 标题层级不超过4级
- 代码块使用语法高亮
- 表格要对齐且简洁

#### Mermaid图表规范
- 架构图使用Mermaid语法
- 图表要清晰易懂
- 包含必要的说明

#### 命名规范
- 文件名使用小写和连字符
- 目录名使用数字编号
- 保持命名的一致性

### 6.4 AI 上下文读取规范 (MCS Protocol)

为保证AI逻辑的确定性并降低成本，执行者（AI）必须遵循以下读取优先级：

#### 6.4.1 最小上下文集 (MCS) 定义

**⚠️ 最高原则**：constitution.md是整个PowerBy工作流的**最高宪法**，包含核心理念、零假设原则、3次尝试原则等。所有阶段都必须严格遵循constitution.md中的原则，任何阶段都不能违背宪法中的规定。

**核心原则**：建立优先级参考体系，确保核心指令始终处于AI注意力的"高亮区"。所有文档都有其意义，但参考优先级不同。

| 执行阶段 | 核心参考文档（优先） | 次要参考文档（需要时） |
|----------|-------------------|----------------|
| **P0 项目初始化** | project-charter.md, **constitution.md** | 无（初始阶段） |
| **P1 需求定义+澄清** | prd.md, function-points.md, clarifications.md, **constitution.md** | 无（严格遵循零假设原则） |
| **P3 技术调研** | prd.md, function-points.md, clarifications.md, **constitution.md** | technical-research.md（技术细节参考） |
| **P4 架构设计** | prd.md, function-points.md, clarifications.md, technical-research.md, **constitution.md** | 无（技术决策导向但遵循宪法） |
| **P5 任务规划** | architecture.md, technical-research.md, **constitution.md** | prd.md（需求背景参考） |
| **P6 开发实现** | tasks.md, architecture.md, 相关代码文件, **constitution.md** | prd.md, clarifications.md, technical-research.md（遇到模糊时参考） |
| **P7 代码审查** | implementation-report.md, tasks.md, architecture.md, **constitution.md** | prd.md, technical-research.md（需要时参考） |
| **P8 项目交付** | code-review-report.md, delivery-report.md, **constitution.md** | 所有中间文档（项目总结参考） |

**重要说明**：
- ✅ **核心参考文档**：AI的主要注意力应集中在这些文档上，这是决策的主要依据
- 📖 **次要参考文档**：当遇到模糊、矛盾或需要澄清时，可以查阅这些文档获取更多信息
- ⚠️ **constitution.md是所有阶段的最高优先级文档**，包含零假设原则、MVP优先、3次尝试原则等核心理念
- 🔄 **SSOT优先级**：constitution.md > 核心参考文档 > 次要参考文档

**设计理念**：
- **注意力集中而非禁止**：所有文档都有其意义，通过优先级引导AI注意力，而不是简单禁止
- **灵活参考机制**：当遇到模糊或需要澄清时，AI可以查阅次要参考文档获取更完整的信息
- **决策依据明确**：核心参考文档是决策的主要依据，次要参考文档提供补充信息
- **符合实际工作场景**：模拟真实工作中工程师的工作方式 - 重点关注核心文档，需要时查阅其他文档

#### 6.4.2 唯一事实源 (SSOT) 优先级原则

**⚠️ 最高优先级**：constitution.md是整个PowerBy工作流的**最高宪法**，优先级高于所有其他文档。任何阶段、任何决策都不能违背constitution.md中的核心理念。

**核心规则**：下游文档的优先级高于上游文档。以最新、最权威的文档为准。

**优先级顺序**：
```
constitution.md（最高宪法）> Gate 8交付 > Gate 7审查 > Gate 6实现 > Gate 5规划 > Gate 4架构 > Gate 3调研 > Gate 1需求 > Gate 0初始化
```

**冲突处理**：
- 若architecture.md与prd.md存在冲突，**必须以architecture.md为准**
- 若tasks.md与architecture.md存在冲突，**必须以tasks.md为准**
- ⚠️ **任何文档都不能违背constitution.md中的原则**，包括零假设原则、MVP优先、3次尝试原则等
- AI若发现跨阶段文档存在**重大冲突**，应立即停止工作并触发「受阻处理协议」寻求澄清

#### 6.4.3 文档活动状态标记

在 `.powerby/iterations.json` 中记录当前迭代的文档状态：

```json
{
  "documents": {
    "prd.md": {
      "status": "Active",
      "gate": "P1",
      "lastUpdated": "2025-12-19",
      "mustRead": ["P3", "P4"]
    },
    "architecture.md": {
      "status": "Active",
      "gate": "P4",
      "lastUpdated": "2025-12-19",
      "mustRead": ["P5", "P6", "P7"]
    },
    "tasks.md": {
      "status": "Active",
      "gate": "P5",
      "lastUpdated": "2025-12-19",
      "mustRead": ["P6", "P7"]
    },
    "clarifications.md": {
      "status": "Frozen",
      "gate": "P1",
      "lastUpdated": "2025-12-19",
      "mustRead": ["P3", "P4"]
    },
    "technical-research.md": {
      "status": "Archived",
      "gate": "P3",
      "lastUpdated": "2025-12-19",
      "mustRead": ["P4"]
    }
  }
}
```

**状态定义**：
- **Active (活动)**：当前阶段正在编写或必须参考的文档
- **Frozen (冻结)**：已通过质量门禁（Gate）的基准文档
- **Archived (归档)**：仅供回溯参考，AI执行任务时不应主动读取

#### 6.4.4 执行约束与验证

**强制约束**：
1. **P6开发实现阶段**：严禁读取constitution.md、prd.md等非工程性文档
2. **Token预算管理**：MCS机制应将单次API请求的Token规模压缩40%-70%
3. **质量回溯**：Gate 7审查失败时，可快速定位是执行问题还是设计问题

**验证机制**：
- 每次AI执行任务前，必须声明将读取的文档清单
- 阶段切换时，明确标注新进入MCS的文档和移出MCS的文档
- 跨阶段冲突时，自动触发SSOT优先级检查

#### 6.4.5 技术价值

✅ **提升指令遵循度**：核心AI指令始终处于注意力高亮区，减少漏掉验收标准的情况

✅ **物理隔绝需求杂音**：powerby-engineer专注于工程实现，仅在权威技术架构指导下工作

✅ **确定性质量回溯**：快速定位问题根因，避免文档堆叠导致的溯源困难

✅ **极大幅度研发降本**：Token规模压缩40%-70%，直接转化为更快响应和更低成本

---

## 7. 质量门禁机制

### 7.1 质量门禁概述

质量门禁（Quality Gate）是PowerBy框架的核心质量保证机制。每个阶段都必须通过相应的质量门禁才能进入下一阶段。

### 7.2 质量门禁清单

| 门禁编号 | 名称 | 检查内容 | 通过标准 |
|----------|------|----------|----------|
| Gate 0 | 项目可行性 | 项目章程的完整性和可行性 | 所有检查项✅ |
| Gate 1 | 需求定稿 | PRD、功能点清单和澄清记录的完整性 | 所有检查项✅ |
| Gate 3 | 技术可行性 | 技术调研的深度和准确性 | 所有检查项✅ |
| Gate 4 | 架构设计清晰性 | 架构图、组件映射、决策记录 | 所有检查项✅ |
| Gate 5 | 任务计划完整性 | 任务分解、验收标准、哲学对齐 | 所有检查项✅ |
| Gate 6 | 实现完整性 | 任务完成、质量标准、测试覆盖 | 所有检查项✅ |
| Gate 7 | 代码审查完整性 | 5大类审计项、功能点验证 | 所有检查项✅ |
| Gate 8 | 交付验收 | 交付物完整性和部署验证 | 所有检查项✅ |

**注**: Gate 1合并了原Gate 1和Gate 2，采用"需求定稿制"机制

### 7.3 门禁执行流程

1. **自检**: 当前阶段完成后进行自检
2. **交叉审查**: 由下游技能进行交叉审查
3. **问题修复**: 发现问题则返回修改
4. **门禁通过**: 所有检查项通过后进入下一阶段

### 7.4 门禁失败处理

当门禁失败时：
1. 记录失败原因
2. 制定修复计划
3. 修复问题
4. 重新提交门禁检查

---

## 8. 迭代管理规范

### 8.1 迭代编号规则

- **格式**: `{三位数字}-{功能名}` (例如: `001-dex-aggregator`)
- **编号**: 从001开始递增
- **命名**: 使用有意义的英文名称

### 8.2 GitHub分支管理 (GitFlow)

PowerBy集成了完整的GitFlow分支管理策略，通过独立的 `powerby-github-branch` 技能实现自动化分支管理。

#### 8.2.1 分支策略架构

```mermaid
graph TB
    main[main - 生产就绪] -->|合并| develop
    develop[develop - 开发集成] -->|合并| feature001[feature/001-task-manager]
    develop -->|合并| feature002[feature/002-payment-system]
    main -->|hotfix| hotfix001[hotfix/003-security-fix]
    develop -->|bugfix| bugfix001[bugfix/002-login-error]
```

#### 8.2.2 分支类型与命名规范

**主分支 (长期分支)**
- `main`: 生产就绪代码，强制PR + 2个审查者
- `develop`: 开发集成分支，强制PR + 1个审查者

**功能分支 (每个迭代)**
- `feature/{id}-{name}`: 完整的P0-P8迭代生命周期
  - 示例: `feature/001-task-manager`, `feature/002-payment-system`
  - 从develop创建，P8完成后合并到develop

**Bug修复分支 (独立流程)**
- `bugfix/{id}-{description}`: 一般Bug修复 (P2/P3级别)
  - 从develop创建，修复后合并到develop
- `hotfix/{id}-{description}`: 紧急修复 (P0/P1级别)
  - 从main创建，同时合并到main和develop

#### 8.2.3 自动化流程集成

**P0-P8迭代分支管理**
```
P1阶段完成 → 自动调用 powerby-github-branch.create_feature_branch()
→ 创建 feature/{id}-{name} 分支

P8阶段完成 → 自动调用 powerby-github-branch.merge_branch()
→ 合并分支到develop并清理
```

**Bug修复分支管理**
```
Bug修复开始 → powerby-bugfix 调用 powerby-github-branch.create_bugfix_branch()
→ 根据严重程度自动选择 bugfix/ 或 hotfix/ 分支

修复完成 → powerby-bugfix 调用 powerby-github-branch.merge_and_cleanup()
→ 合并到相应分支并清理
```

#### 8.2.4 技能协作

| 调用方 | 功能 | 触发时机 | 自动化程度 |
|--------|------|---------|-----------|
| powerby-command | 创建feature分支 | P1阶段完成后 | 全自动 |
| powerby-command | 合并feature分支 | P8阶段完成后 | 全自动 |
| powerby-bugfix | 创建bugfix/hotfix分支 | Bug修复开始时 | 全自动 |
| powerby-bugfix | 合并和清理分支 | Bug修复完成后 | 全自动 |

#### 8.2.5 分支管理工具

PowerBy提供了三个自动化脚本：

- `scripts/create-iteration-branch.sh`: 创建迭代分支
- `scripts/cleanup-branches.sh`: 清理已合并分支
- `scripts/list-branches.sh`: 查看分支状态和进度

#### 8.2.6 分支策略优势

- ✅ **并行开发**: 多个feature分支同时进行，不相互干扰
- ✅ **独立Bug修复**: bugfix/hotfix独立流程，快速响应问题
- ✅ **标准化流程**: 清晰的命名规范和生命周期管理
- ✅ **自动集成**: 与P0-P8流程和Bug修复流程无缝集成
- ✅ **技能解耦**: 分支管理独立为专门技能，职责清晰

### 8.3 文档组织

- **根目录**: `docs/iterations/{id}-{name}/`
- **元数据**: `.powerby/iterations.json`
- **版本控制**: 所有文档都纳入版本控制

### 8.4 状态追踪

在 `.powerby/iterations.json` 中记录：
- 迭代基本信息
- 当前阶段
- 完成状态
- 质量门禁状态
- 关键日期

---

## 9. 受阻处理协议

### 9.1 3次尝试原则

**针对同一问题，最多尝试3次。如果依然无法解决，立刻停止。**

### 9.2 四步处理流程

#### 第一步：记录失败过程
详细记录：
1. 具体尝试内容
2. 错误信息
3. 失败原因分析

#### 第二步：研究替代方案
寻找并分析2-3个类似实现案例：
1. 搜索项目中是否有类似场景
2. 查找其他工程师的处理方法
3. 记录不同方法的差异和优缺点

#### 第三步：反思基本问题
深入思考：
1. 抽象层级是否正确
2. 能否拆分得更小
3. 是否存在更简单的整体方案

#### 第四步：尝试不同角度
1. 技术栈角度
2. 架构模式角度
3. 简化策略角度

### 9.3 阻塞报告格式

当3次尝试后仍无法解决时，生成结构化的阻塞报告：
```markdown
# 阻塞问题报告

## 问题描述
[清晰描述遇到的具体阻塞问题]

## 尝试记录
[详细记录三次尝试的过程]

## 替代方案研究
[记录找到的类似实现案例]

## 根本问题分析
[深入分析根本原因]

## 最终建议
[基于分析的建议]

## 需要用户决策的问题
[需要用户明确指示的问题]
```

### 9.4 执行要求

- **立即停止**: 3次尝试后必须立即停止
- **结构化输出**: 必须按照标准格式生成报告
- **寻求指导**: 将报告提交给用户
- **不跳过原则**: 绝对不允许跳过此协议

---

## 10. 最佳实践

### 10.1 需求阶段最佳实践

1. **保持简洁**: PRD应该简洁明了，避免冗长
2. **用户视角**: 始终从用户角度思考需求
3. **优先级明确**: P0/P1/P2优先级要有明确依据
4. **可测试**: 每个功能点都要有可测试的验收标准
5. **及时澄清**: 发现模糊点立即澄清

### 10.2 架构阶段最佳实践

1. **MVP优先**: 优先考虑MVP实现路径
2. **扩展性**: 为未来发展预留扩展点
3. **组件化**: 保持高内聚、低耦合
4. **决策记录**: 记录所有技术决策的依据
5. **可视化**: 使用图表辅助说明

### 10.3 实现阶段最佳实践

1. **TDD**: 采用测试驱动开发
2. **小步提交**: 保持小步提交的节奏
3. **代码审查**: 及时进行代码审查
4. **持续集成**: 建立持续集成流程
5. **文档同步**: 代码和文档同步更新

### 10.4 审查阶段最佳实践

1. **基准文档**: 严格对照基准文档审查
2. **结构化**: 使用结构化的审查清单
3. **客观公正**: 保持客观公正的态度
4. **建设性**: 提供建设性的修改建议
5. **可追溯**: 保持完整的追溯链

### 10.5 协作最佳实践

1. **Mixin思维**: 采用增量式协作
2. **及时沟通**: 及时沟通问题和风险
3. **文档共享**: 及时共享文档和决策
4. **相互尊重**: 尊重不同角色的专业意见
5. **持续改进**: 从每个迭代中学习和改进

---

## 11. 常见问题

### Q1: 如果某个阶段的质量门禁失败怎么办？

**A**: 当质量门禁失败时，应该：
1. 详细分析失败原因
2. 制定修复计划
3. 修复问题
4. 重新提交门禁检查
5. 如果多次失败，触发受阻处理协议

### Q2: 是否可以跳过某个阶段？

**A**: 不建议跳过任何阶段。每个阶段都有其存在的价值和必要性。如果确实需要跳过，必须：
1. 明确记录跳过的原因
2. 获得所有干系人的同意
3. 评估跳过可能带来的风险

### Q3: 如何处理需求变更？

**A**: 需求变更是常态，处理方式：
1. 评估变更的影响范围
2. 更新相关文档
3. 重新进行质量门禁
4. 记录变更历史

### Q4: 如何平衡进度和质量？

**A**: 质量和进度都很重要，建议：
1. 设定合理的质量标准
2. 采用分阶段的质量检查
3. 及时识别和解决风险
4. 保持透明和开放的沟通

### Q5: 多人协作时如何保持一致性？

**A**: 多人协作时：
1. 使用统一的文档模板
2. 建立清晰的协作流程
3. 使用版本控制管理文档
4. 定期进行同步会议
5. 建立决策记录机制

---

## 12. 附录

### 12.1 术语表

| 术语 | 定义 |
|------|------|
| PRD | Product Requirements Document，产品需求文档 |
| Gate | 质量门禁，阶段间的质量检查点 |
| MVP | Minimum Viable Product，最小可行产品 |
| TDD | Test-Driven Development，测试驱动开发 |
| SOLID | 面向对象设计的五大原则 |
| DRY | Don't Repeat Yourself，不要重复自己 |
| KISS | Keep It Simple，保持简单 |
| Mixin | 增量式协作和贡献模式 |

### 12.2 文档模板

#### PRD模板
```markdown
# 产品需求文档

## 项目概述
[项目名称、目标、背景]

## 用户画像
[目标用户特征]

## 核心功能
[P0/P1/P2功能列表]

## 非功能需求
[性能、安全、可维护性等]

## 约束条件
[技术、业务、时间约束]
```

#### Architecture模板
```markdown
# 技术架构设计

## 需求概述
[从PRD提炼的需求]

## 核心技术选型
[技术栈选择和理由]

## 核心架构设计
[Mermaid架构图]

## 组件与需求映射
[组件与功能点的对应关系]

## 关键技术决策
[技术决策点记录]

## 非功能需求
[性能、安全等考虑]
```

### 12.3 检查清单

#### P1阶段检查清单
- [ ] PRD结构完整
- [ ] 功能点清单包含所有P0功能
- [ ] 每个功能点包含8要素
- [ ] 功能优先级明确

#### P4阶段检查清单
- [ ] 架构图清晰
- [ ] 组件职责明确
- [ ] 组件与需求映射完整
- [ ] 技术决策记录完整

#### P7阶段检查清单
- [ ] 5大类审计项完成
- [ ] 功能点一致性验证
- [ ] 审计报告结构完整
- [ ] 结论明确

### 12.4 参考资源

- [PowerBy Constitution](../powerby-constitution.md)
- [PowerBy Command 文档](../powerby-command/README.md)
- [技能定义文档](../skills/)

---

**审核状态**: 已优化MCS协议，建立优先级参考体系

---

## 📋 审核清单

本文档已准备好接受AI审核，请重点关注以下方面：

1. **完整性**: 是否涵盖了PowerBy工作流的所有重要方面？
2. **准确性**: 流程和原则的描述是否准确？
3. **清晰性**: 文档结构是否清晰，易于理解？
4. **一致性**: 前后内容是否一致？
5. **实用性**: 是否提供了足够的实践指导？
6. **可操作性**: 是否具有可操作性？

**请提供具体的优化建议和修改意见。**
