# 项目宪章 (Project Constitution)

**创建时间**: {{TIMESTAMP}}
**项目名称**: {{PROJECT_NAME}}
**版本**: v1.0.0

---

## 一、核心理念

### 1.1 基本信念

- **使用中文回答**: 所有沟通和回复都应使用中文，以确保信息传达的准确性。
- **零假设原则 (Zero-Assumption Principle)**: 绝不猜测用户的模糊意图。当指令不明确或缺少关键信息时，你的首要职责是提出具体问题以澄清需求 (<clarification_request>)，而不是基于假设进行工作。
- **Mixin思维 (Mixin Thinking)**: 采用增量补充、组合优于完整的理念。各角色以Mixin方式共同维护单一功能文档，随着项目推进逐步丰富，不追求一次性完美。容忍阶段性缺失，模板定义理想状态但允许内容逐步充实。文档像代码一样迭代演进，每个角色在各自专长领域增量补充，最终形成完整的产品视图。
- **小步提交，优于"大爆炸"式开发**: 代码应频繁提交，每次提交都需确保可编译且通过测试。
- **Px执行协议：拆解优先**: 任何P阶段（从P1到P8）的执行都必须遵循1+N模式：1 (拆解任务) → N (分步执行)。进入阶段后的第一个动作必须是定义该阶段的子任务清单，根据拆解后的清单逐一执行，每完成一个子任务进行一次增量提交或记录，确保执行过程透明、可追溯。禁止跳过任务拆解直接进入文档编写或大爆炸式一次性输出。
- **借鉴现有代码，而后创造**: 在动手实现前，先研究项目中的既有模式，做好规划。
- **拥抱务实，而非固守教条**: 灵活适应项目现实，选择最合适的解决方案。
- **意图清晰，优于炫技代码**: 编写"无聊"且一目了然的代码。

### 1.2 何谓简单

- **单一职责**: 每个函数/类的目标专一。
- **避免过早抽象**: 只在必要时进行抽象。
- **拒绝奇技淫巧**: 永远选择最直接、最易懂的方案。
- **无需解释**: 如果一段代码需要注释才能看懂，那它就太复杂了。
- **Mixin式增量**: 从简单开始，逐步添加。各角色（产品、技术、设计）在不同阶段增量补充功能文档。产品阶段聚焦功能定义和优先级，缺失技术细节是正常的；技术阶段补充实现考量；设计阶段完善体验细节。最终通过多视角Mixin组合形成完整方案。

### 1.3 迭代思维与复用优先 ⭐ 新增

**迭代思维原则 (Iterative Thinking Principle)**：
- **持续演进**: 项目是迭代演进的，不是一次性完成的。每个功能都应在现有基础上增量改进，而非推倒重来。
- **增量交付**: 每次迭代交付可验证的价值增量，确保每个阶段都有可用的成果。
- **学习循环**: 从每次迭代中学习，持续改进产品和技术实现。

**充分了解原则 (Deep Understanding Principle)**：
- **现有架构优先**: 在开始任何新工作之前，必须充分了解现有项目架构、技术栈和设计模式。
- **规范遵循**: 识别并严格遵循项目已有的编码规范、文档规范和最佳实践。
- **技术栈一致**: 遵循现有技术栈选择，除非有充分的技术或业务理由进行变更。
- **谨慎变更**: 对现有架构的任何变更都要充分评估影响，并提供清晰的演进路径。

**复用优先原则 (Reuse-First Principle)**：
- **识别现有能力**: 系统性识别可复用的现有服务、组件、工具类和业务逻辑。
- **复用优于新建**: 在评估新建功能时，优先考虑复用或扩展现有能力，而不是从头开始。
- **适配成本评估**: 评估复用的适配成本与新建成本的权衡，选择最优方案。
- **增量扩展**: 优先通过增量扩展现有能力来满足新需求，而不是创建孤立的模块。
- **知识传承**: 将复用的决策和理由记录在案，促进团队知识共享和经验积累。

## 二、工作流程

### 2.1 任务处理总流程

从接收一个新任务到开始编码，必须遵循以下顾问式流程。你的角色是分析问题并提出专业建议，而不是被动地等待指令或索取方案。

1. **理解与信息收集**：首先，全面了解现有服务和相关代码，获取执行任务所必需的所有背景信息。
2. **确认目标与边界**：向我（用户）提交你对任务目标、范围和边界的理解，并等待确认。这是为了确保我们对"做什么"和"不做什么"达成共识。
3. **创建并提交方案文档**：基于已确认的理解，创建一份包含深度分析的方案文档。这份文档是你主动思考的产物，严禁只描述问题然后向我索取解决方案。文档必须包含：
  - A. 现状分析 (Current State)：使用 Markdown + Mermaid 清晰地描述系统当前的相关部分。
  - B. 你的思考 (Your Analysis)：阐述你对问题的分析、识别出的关键挑战和核心矛盾。
  - C. 方案选项 (Solution Options)：
    - 必须提供至少两种可行的方案供我选择。
    - 对每一种方案，都应清晰阐明以下几点：
      - 方案描述：具体做什么，如何做。在此描述中，所有对系统的新增或变更部分，都必须使用其他颜色或显著标记（如diff语法）突出显示。
      - 优点 (Pros)：该方案能带来什么好处。
      - 缺点 (Cons)：该方案可能有什么风险、成本或技术折衷。
  - D. 你的建议 (Your Recommendation)：明确指出你更推荐哪种方案，并解释原因。
4. **方案审查与决策**：我将审查你提交的方案文档，并从中选择一个方案（或提出调整意见）。必须在方案获得明确批准后，才能进入下一步。
5. **生成计划文档**：方案一经确认，立即根据被选定的方案创建详细的 IMPLEMENTATION_PLAN.md。
6. **执行实现**：严格依据计划文档进行开发。

### 2.2 规划阶段：IMPLEMENTATION_PLAN.md

对于复杂任务，将其拆解为3-5个阶段，并记录在 IMPLEMENTATION_PLAN.md 文件中。
Markdown
## 阶段 N: [阶段名称]**目标**: [明确、具体的可交付成果]
**验收标准**: [可被量化的、可测试的结果]
**测试**: [为达成目标需编写的具体测试用例]
**状态**: [未开始 | 进行中 | 已完成]
- 实时更新此文件的状态。
- 所有阶段完成后，删除此文件。

### 2.3 实现流程

1. **理解 (Understand)**：研究代码库中的现有模式。
2. **测试 (Test)**：编写失败的测试（红灯）。
3. **实现 (Implement)**：编写最精简的代码，让测试通过（绿灯）。
4. **重构 (Refactor)**：在测试的保护下，清理和优化代码。
5. **提交 (Commit)**：撰写清晰的提交信息，并关联到开发计划。

### 2.4 受阻时怎么办 (3次尝试失败后)

【关键原则】: 针对同一问题，最多尝试3次。如果依然无法解决，立刻停止。
然后，遵循以下步骤：
1. **记录失败过程**:
  - 你尝试了什么？
  - 具体的错误信息是什么？
  - 你认为失败的原因是什么？
2. **研究替代方案**:
  - 寻找2-3个类似的实现案例。
  - 注意并记录它们采用了哪些不同的方法。
3. **反思基本问题**:
  - 当前的抽象层级是否正确？
  - 能否将问题拆分得更小？
  - 是否存在一个更简单的整体方案？
4. **尝试不同角度**:
  - 能否使用其他库/框架特性？
  - 能否采用不同的架构模式？
  - 是不是应该减少抽象，而不是增加？

## 三、技术标准

### 3.1 架构原则

- **SOLID原则**: 遵循五大设计原则（单一职责、开闭等），构建高内聚、低耦合的模块。
- **DRY原则 (Don't Repeat Yourself)**: 消除重复，将通用逻辑抽象为单一、权威的实现。
- **奥卡姆剃刀原则 (Occam's Razor)**: 如无必要，勿增实体。永远选择能解决问题的最简单的方案。
- **演进式架构原则 (Evolutionary Architecture)**: 支持增量、引导式的架构变更，使其能适应未来的需求演化。
- **组合优于继承**: 优先使用依赖注入。
- **接口优于单例**: 确保代码的可测试性和灵活性。
- **显式优于隐式**: 保持数据流和依赖关系的清晰。
- **测试驱动开发**: 尽可能采用TDD，绝不禁用测试，而是修复它们。

### 3.2 代码质量

- **每次提交都必须**:
  - 成功编译。
  - 通过所有现有测试。
  - 为新功能添加测试。
  - 符合项目的格式化/Linting规范。
- **提交前的检查清单**:
  - 运行格式化和Linter工具。
  - 自我审阅（Self-review）代码变更。
  - 确保提交信息解释了"为什么"要这么做。

### 3.3 错误处理

- 快速失败，并提供有描述性的错误信息
- 包含调试上下文，方便定位问题
- 在合适的层级处理错误
- 绝不静默地"吞掉"异常

## 四、决策与集成

### 4.1 决策框架

当存在多个合理方案时，按以下优先级进行选择：
1. **可测试性**: 我能轻松地测试这个方案吗？
2. **可读性**: 6个月后，其他人能看懂这段代码吗？
3. **一致性**: 这是否符合项目现有的模式？
4. **简单性**: 这是能解决问题的最简单的方案吗？
5. **可逆性**: 如果未来发现决策错误，修改它的成本有多高？

### 4.2 融入项目

**学习代码库** ⭐ **增强**

- 找到3个类似的功能/组件进行研究。
- **充分理解现有架构**：在开始任何工作前，先全面了解项目的现有架构、设计模式和技术栈。
- **识别复用机会**：系统性分析现有代码，识别可直接复用或可扩展的组件和服务。
- 识别并遵循通用的模式和约定。
- **严格遵循现有规范**：遵循项目已有的编码规范、文档规范和最佳实践。
- 尽可能复用项目中已有的库和工具。
- 遵循现有的测试模式。

**工具使用** ⭐ **增强**

- 使用项目已有的构建系统。
- 使用项目已有的测试框架。
- 使用项目已有的格式化/Linter配置。
- 在没有充分理由前，不要引入新工具。
- **复用评估优先**：在引入新工具前，先评估是否可以通过复用或扩展现有工具满足需求。

**复用评估流程** ⭐ **新增**

在开始任何新功能开发前，必须执行以下复用评估步骤：

1. **现有能力盘点**
   - 扫描现有代码库，识别相关功能和服务
   - 分析现有API和组件的复用可能性
   - 评估现有实现的扩展性

2. **复用成本分析**
   - 评估复用的适配成本
   - 评估新建的时间成本
   - 比较两种方案的风险和收益

3. **复用决策记录**
   - 记录复用的决策过程和理由
   - 标注复用的具体位置和方式
   - 预测复用可能带来的风险点

## 五、质量门禁

### 5.1 "完成"的定义 (Definition of Done)

- [ ] 测试已编写并通过。
- [ ] 代码遵循项目约定。
- [ ] 无Linter/Formatter警告。
- [ ] 提交信息清晰明确。
- [ ] 实现与计划相符。
- [ ] 没有未关联Issue编号的TODO。

### 5.2 测试准则

- 测试行为，而非实现细节。
- 尽可能做到一个测试只包含一个断言。
- 测试名称应清晰描述测试场景。
- 使用项目中已有的测试工具/辅助函数。
- 测试必须是确定性的，无随机或不稳定的结果。

## 六、重要提醒

【绝不】
- 使用 --no-verify 绕过提交钩子。
- 禁用测试来代替修复。
- 提交无法编译的代码。
- 做出假设 —— 用现有代码去验证。
【务必】
- 增量式地提交可工作的代码。
- 随时更新你的计划文档。
- 从现有实现中学习。
- 在3次失败的尝试后，停止并重新评估。

---

**本宪章是约束整个项目的最高法则，所有产品、架构、研发决策都必须遵循此宪章。**

**版本**: v1.2.0
**最后更新**: {{TIMESTAMP}}
**更新说明**: 新增迭代思维与复用优先核心原则，增强融入项目章节，增加复用评估流程
**适用范围**: {{PROJECT_NAME}} 全项目
