# Px执行协议实施指南

**版本**: v1.0.0
**创建日期**: 2025-12-19
**适用范围**: PowerBy 全项目
**目标**: 指导如何应用Px执行协议，养成"先拆解，后执行"的良好习惯

---

## 📋 目录

1. [协议概述](#1-协议概述)
2. [快速上手](#2-快速上手)
3. [tasks.md使用指南](#3-tasksmd使用指南)
4. [各阶段应用示例](#4-各阶段应用示例)
5. [AI助手配合](#5-ai助手配合)
6. [最佳实践](#6-最佳实践)
7. [常见问题](#7-常见问题)

---

## 1. 协议概述

### 1.1 核心理念

**Px执行协议**是基于奥卡姆剃刀原则的最小侵入式优化，旨在解决AI"大爆炸"式交付的问题，建立"先拆解，后执行"的良好习惯。

**1+N模式**：
- **1 (拆解任务)**：进入P阶段后的第一个动作
- **N (分步执行)**：根据清单逐一执行

### 1.2 核心原则

#### ✅ 强制执行
- 禁止直接交付
- 必须先拆解任务
- 每完成一个子任务标记[x]

#### ✅ 增量执行
- 每次只专注于一个子任务
- 完成一个标记一个
- 遇到阻塞记录并继续

#### ✅ 可追溯
- 所有进度记录在tasks.md
- 预估vs实际时间对比
- 便于复盘和改进

---

## 2. 快速上手

### 2.1 第一次使用

#### Step 1: 创建tasks.md
```bash
# 进入项目目录
cd your-project

# 在docs/iterations/{id}-{name}/目录下创建
touch tasks.md
```

#### Step 2: 初始结构
```markdown
# 任务看板 (Task Board)

## P0: 项目初始化 ✅
- [x] T001: 创建项目结构
- [x] T002: 生成项目宪章
- [x] T003: 初始化Git仓库

## P1: 需求定义 🔄 (进行中)
- [ ] T101: [待拆解]

## P2: 需求澄清 ⏳ (等待中)
- [ ] T201: [待P1完成后拆解]

## P3: 技术调研 ⏳ (等待中)
- [ ] T301: [待P2完成后拆解]

## P4: 架构设计 ⏳ (等待中)
- [ ] T401: [待P3完成后拆解]

## P5: 任务规划 ⏳ (等待中)
- [ ] T501: [待P4完成后拆解]

## P6: 开发实现 ⏳ (等待中)
- [ ] T601: [待P5完成后拆解]

## P7: 质量审查 ⏳ (等待中)
- [ ] T701: [待P6完成后拆解]

## P8: 发布交付 ⏳ (等待中)
- [ ] T801: [待P7完成后拆解]
```

### 2.2 进入新阶段

当您准备开始一个新阶段时：

#### ✅ 正确做法
```
"开始执行P1阶段。按照Px执行协议，我先拆解子任务清单..."
→ 在tasks.md中列出P1的6个子任务
→ 开始逐项执行
```

#### ❌ 错误做法
```
"现在开始写PRD文档..."
→ 直接开始写，没有拆解
```

---

## 3. tasks.md使用指南

### 3.1 文件定位

**位置**：`docs/iterations/{id}-{name}/tasks.md`

**创建时机**：P1阶段开始时（之前由P0初始化创建）

### 3.2 结构规范

#### 标题格式
```markdown
# 任务看板 (Task Board)
```

#### 阶段区块格式
```markdown
## P{X}: {阶段名称} {状态图标} ({状态文本})
- [ ] T{ID}: {任务描述} (预估时间)
- [x] T{ID}: {已完成任务} (实际时间)
- [🔄] T{ID}: {进行中任务}
```

#### 状态图标说明
- `[ ]` - 未开始
- `[x]` - 已完成
- `[🔄]` - 进行中
- `[⏸]` - 暂停
- `[❌]` - 阻塞

### 3.3 任务ID规则

| 阶段 | ID范围 | 示例 |
|-----|-------|------|
| P0 | T001-T099 | T001, T002, T003 |
| P1 | T101-T199 | T101, T102, T103 |
| P2 | T201-T299 | T201, T202, T203 |
| P3 | T301-T399 | T301, T302, T303 |
| P4 | T401-T499 | T401, T402, T403 |
| P5 | T501-T599 | T501, T502, T503 |
| P6 | T601-T699 | T601, T602, T603 |
| P7 | T701-T799 | T701, T702, T703 |
| P8 | T801-T899 | T801, T802, T803 |

### 3.4 任务描述规范

#### ✅ 好的任务描述
```
- [ ] T101: 收集需求原始输入 (30分钟)
- [ ] T102: 定义功能规格框架 (45分钟)
- [ ] T103: 拆解MVP功能点 (60分钟)
```

#### ❌ 不好的任务描述
```
- [ ] T101: 写PRD
- [ ] T102: 做一些分析
- [ ] T103: 整理文档
```

### 3.5 时间预估规则

#### 预估原则
- 以"单个会话可完成"为准
- 保守估计，宁可多不要少
- 记录预估时间，便于优化

#### 时间范围建议
- 最小：15分钟
- 最大：2小时
- 超过2小时的任务需要进一步拆分

---

## 4. 各阶段应用示例

### 4.1 P1: 需求定义

#### 任务拆解
```markdown
## P1: 需求定义 🔄 (进行中)

### 阶段目标
将产品想法转化为清晰的、带有MVP优先级的功能点清单

### 子任务列表
- [ ] T101: 收集需求原始输入 (30分钟)
- [ ] T102: 定义功能规格框架 (45分钟)
- [ ] T103: 拆解MVP功能点 (60分钟)
- [ ] T104: 标记P0/P1/P2优先级 (30分钟)
- [ ] T105: 明确范围边界 (30分钟)
- [ ] T106: 生成待决策清单 (30分钟)

⏰ 预估总时间: 3.75小时
```

#### 执行过程
```markdown
## P1: 需求定义 🔄 (进行中)

### 子任务列表
- [x] T101: 收集需求原始输入 (30分钟) ✅ 实际25分钟
- [x] T102: 定义功能规格框架 (45分钟) ✅ 实际50分钟
- [🔄] T103: 拆解MVP功能点 (60分钟) ⏳ 进行中
- [ ] T104: 标记P0/P1/P2优先级 (30分钟)
- [ ] T105: 明确范围边界 (30分钟)
- [ ] T106: 生成待决策清单 (30分钟)

⏰ 已用时间: 1小时15分钟
⏳ 剩余时间: 2小时30分钟
```

### 4.2 P3: 技术调研

#### 任务拆解
```markdown
## P3: 技术调研 ⏳ (等待中)

### 阶段目标
针对关键技术决策进行调研，解决技术选型和可行性问题

### 子任务列表
- [ ] T301: 识别技术调研项 (30分钟)
- [ ] T302: 评估技术栈选型 (45分钟)
- [ ] T303: 评估第三方服务集成 (45分钟)
- [ ] T304: 评估性能/安全方案 (30分钟)
- [ ] T305: 技术风险评估 (30分钟)
- [ ] T306: 记录最终决策 (30分钟)

⏰ 预估总时间: 3.5小时
```

### 4.3 P4: 架构设计

#### 任务拆解
```markdown
## P4: 架构设计 ⏳ (等待中)

### 阶段目标
将需求和技术方案转化为清晰的、可视化的架构设计

### 子任务列表
- [ ] T401: 需求解读与对齐 (30分钟)
- [ ] T402: 绘制核心架构图 (60分钟)
- [ ] T403: 定义组件职责 (45分钟)
- [ ] T404: 创建组件与需求映射表 (30分钟)
- [ ] T405: 设计数据模型 (45分钟)
- [ ] T406: 定义API契约 (45分钟)
- [ ] T407: Constitution Gates验收 (30分钟)

⏰ 预估总时间: 4.75小时
```

---

## 5. AI助手配合

### 5.1 标准提示词

当您需要AI协助时，可以使用以下标准提示词：

#### 启动新阶段
```
"请使用powerby-{skill} skill，帮助我执行P{X}阶段。按照Px执行协议，请先帮我拆解本阶段的子任务清单，然后逐项执行。"
```

#### 执行过程中
```
"正在执行子任务 T{XYZ}: {任务描述}
请帮我完成这个任务，完成后我会在tasks.md中标记为[x]。"
```

#### 遇到阻塞
```
"子任务 T{XYZ} 遇到阻塞：{阻塞原因}
请记录在tasks.md中，并继续执行下一个可进行的任务。"
```

### 5.2 AI响应模式

AI将遵循以下标准响应模式：

#### 进入新阶段时
```
"理解。我将帮助您执行P{X}阶段。

按照Px执行协议，我先为您拆解本阶段的子任务清单：

## P{X}: {阶段名称} 🔄 (进行中)

### 阶段目标
{目标描述}

### 子任务列表
- [ ] T{XYZ}: {任务1} ({时间})
- [ ] T{XYZ}: {任务2} ({时间})
...

⏰ 预估总时间: {总时间}

现在开始执行第一个任务：{任务1}"
```

#### 执行任务时
```
"正在执行子任务 T{XYZ}: {任务描述}

{任务内容}

完成后请在tasks.md中标记为[x]，然后继续下一个任务：{下一个任务}"
```

#### 遇到阻塞时
```
"子任务 T{XYZ} 遇到阻塞：{阻塞原因}

已在tasks.md中记录：
```
markdown
❌ T{XYZ}: {任务描述} - 阻塞原因: {原因}
```

继续执行下一个可进行的任务：{下一个任务}"
```

---

## 6. 最佳实践

### 6.1 任务拆解原则

#### ✅ 好的拆解
- 颗粒度适中（15分钟-2小时）
- 每个任务有明确输出
- 逻辑顺序清晰
- 可独立执行

#### ❌ 不好的拆解
- 颗粒度过大（超过2小时）
- 没有明确输出
- 任务间依赖混乱
- 无法独立执行

### 6.2 执行技巧

#### 时间管理
1. **估算要保守**：宁可多估，不要少估
2. **记录实际时间**：便于下次优化
3. **控制节奏**：避免疲劳作业
4. **及时调整**：根据实际情况调整计划

#### 进度追踪
1. **实时更新**：完成一个标记一个
2. **记录阻塞**：及时记录阻塞原因
3. **预估对比**：记录预估vs实际
4. **定期复盘**：每周回顾进度

### 6.3 团队协作

#### 任务分配
- 基于任务ID分配
- 明确任务负责人
- 记录开始和完成时间
- 及时同步进度

#### 沟通要点
- 使用tasks.md作为沟通基准
- 定期同步进度
- 及时更新阻塞状态
- 共享经验教训

---

## 7. 常见问题

### Q1: 任务拆解到什么颗粒度合适？

**A**: 以"单个会话可完成"为准，建议：
- 最小：15分钟
- 最大：2小时
- 超过2小时需要进一步拆分

### Q2: 遇到阻塞任务怎么办？

**A**: 记录在tasks.md中并继续下一个任务：
```markdown
❌ T103: 拆解MVP功能点 - 阻塞原因: 需要更多业务信息
```

### Q3: 可以修改已分解的任务吗？

**A**: 可以，但建议：
- 记录修改原因
- 保留修改历史
- 及时更新预估时间

### Q4: 快速流程中如何使用？

**A**: 同样遵循1+N模式，但子任务颗粒度更粗：
- P1阶段3个子任务（每个1-1.5小时）
- 其他阶段2-3个子任务

### Q5: AI不遵守执行协议怎么办？

**A**: 提醒AI使用标准提示词：
```
"请遵守Px执行协议：先拆解任务，再执行。"
```

### Q6: 忘记更新tasks.md怎么办？

**A**: 建议：
- 每次完成任务立即更新
- 使用版本控制追踪变更
- 定期检查tasks.md状态

---

## 📚 相关文档

- [PowerBy生命周期框架](./powerby-lifecycle-framework.md)
- [P0+P1流程合并优化方案](./P0_P1_MERGE_OPTIMIZATION_PLAN.md)
- [快速流程定义](../skills/powerby-command/templates/.claude/commands/powerby-quick.md)

---

**维护者**: 流程维护者 (Process Maintainer)
**最后更新**: 2025-12-19
**版本**: v1.0.0
