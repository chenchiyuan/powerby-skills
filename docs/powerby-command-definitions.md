# PowerBy 指令详细定义

**版本**: v1.0.0
**设计日期**: 2025-12-18
**基于**: PowerBy指令流程架构

---

## 一、指令总览

### 1.1 指令分类

PowerBy指令流程包含6个核心指令，分为3个层次：

#### 初始化层
- `/powerby.initialize` - 项目初始化和宪章建立

#### 产品层
- `/powerby.define` - 需求定义和功能点清单
- `/powerby.clarify` - 需求澄清和边界明确

#### 技术层
- `/powerby.design` - 技术调研和架构设计
- `/powerby.implement` - 开发规划和实现
- `/powerby.review` - 代码审查和交付

### 1.2 指令执行流程

```text
用户输入 → 指令解析器 → 验证前置条件 → 执行指令逻辑 → 质量门禁检查 → 生成输出
```

---

## 二、指令详细定义

### 2.1 `/powerby.initialize` 指令

**指令描述**: 项目初始化和宪章建立

#### 指令格式
```bash
/powerby.initialize [项目名称] [项目描述] [选项]
```

#### 选项参数
- `--team`: 团队成员（可选）
- `--tech-stack`: 技术偏好（可选）
- `--template`: 宪章模板（可选，默认使用标准模板）

#### 前置条件检查
- ✅ 当前目录不是Git仓库或已确认初始化新仓库
- ✅ 用户有创建目录和文件的权限
- ✅ 网络连接正常（如需下载模板）

#### 执行逻辑

**步骤1: 输入验证**
```markdown
1. 验证项目名称格式（不能为空，只能包含字母、数字、连字符）
2. 验证项目描述长度（至少10个字符）
3. 检查团队成员格式（如果提供）
4. 检查技术偏好格式（如果提供）
```

**步骤2: 创建项目结构**
```bash
mkdir -p .powerby
mkdir -p docs/iterations
mkdir -p templates
```

**步骤3: 生成项目宪章**
使用 `templates/constitution-template.md` 生成 `docs/constitution.md`

**步骤4: 初始化Git仓库**
```bash
git init
echo "# 项目名称" > README.md
git add .
git commit -m "feat: 初始项目宪章"
```

**步骤5: 创建项目元数据**
生成 `.powerby/project.json`:
```json
{
  "name": "项目名称",
  "description": "项目描述",
  "version": "1.0.0",
  "phase": "P0",
  "status": "initialized",
  "created": "2025-12-18",
  "team": ["成员1", "成员2"],
  "techStack": ["技术1", "技术2"]
}
```

**步骤6: Gate 0检查**
执行以下检查：
- [ ] 项目宪章文件存在且包含所有必需章节
- [ ] 目录结构符合PowerBy规范
- [ ] Git仓库已初始化
- [ ] 元数据文件已创建且格式正确

#### 错误处理

**错误类型1: 项目名称无效**
```
错误: 项目名称只能包含字母、数字和连字符，且不能为空
解决: 请使用正确的项目名称格式
```

**错误类型2: Git初始化失败**
```
错误: 无法初始化Git仓库
解决: 请检查当前目录权限，或手动初始化Git仓库
```

**错误类型3: 文件创建失败**
```
错误: 无法创建项目文件
解决: 请检查磁盘空间和目录权限
```

#### 输出示例

```markdown
✅ 项目初始化完成

📁 项目结构:
  .powerby/
    └── project.json
  docs/
    └── constitution.md
  templates/
  README.md

📋 项目信息:
  名称: my-project
  描述: 这是一个示例项目
  阶段: P0
  状态: initialized

🔍 下一步:
  请使用 /powerby.define 指令开始需求定义阶段
```

---

### 2.2 `/powerby.define` 指令

**指令描述**: 需求定义和功能点清单生成

#### 指令格式
```bash
/powerby.define [产品想法] [选项]
```

#### 选项参数
- `--user-group`: 目标用户群体
- `--problem`: 核心业务问题
- `--timeline`: 预期上线时间
- `--constraints`: 特殊约束条件
- `--iterations`: 迭代编号（可选，默认自动分配）

#### 前置条件检查
- ✅ `/powerby.initialize` 已完成
- ✅ 项目宪章存在
- ✅ 当前阶段状态为 P0
- ✅ 用户提供了产品想法描述

#### 执行逻辑

**步骤1: 输入验证**
```markdown
1. 验证产品想法描述长度（至少20个字符）
2. 检查目标用户群体格式（如果提供）
3. 检查核心业务问题格式（如果提供）
4. 检查预期上线时间格式（如果提供）
5. 检查特殊约束条件格式（如果提供）
```

**步骤2: MVP功能分解**
基于产品想法，提取MVP功能点：
```markdown
1. 识别核心价值：一句话定义产品为用户解决的唯一、最核心的问题
2. 定义最小功能集：能解决核心问题的、绝对最小的功能集合
3. 无情削减：挑战每个功能点的必要性
4. 明确推迟：标记非MVP核心功能为"可推迟项"
```

**步骤3: 生成功能点优先级**
```markdown
[P0]: 核心功能，必须实现
[P1]: 重要功能，建议实现
[P2]: 增强功能，可以推迟
```

**步骤4: 生成PRD文档**
使用 `templates/prd-template.md` 生成 `docs/iterations/{iter}-{name}/prd.md`

**步骤5: 生成功能点清单**
使用 `function-point-checker` 技能生成 `docs/iterations/{iter}-{name}/function-points.md`

**步骤6: [NEEDS CLARIFICATION]处理**
如果存在模糊点，标记为 `[NEEDS CLARIFICATION: 具体问题]`

**步骤7: Gate 1检查**
执行以下检查：
- [ ] MVP核心价值已用一句话定义
- [ ] 所有功能点已标记优先级([P0]/[P1]/[P2])
- [ ] 范围边界已明确(In-Scope / Out-of-Scope)
- [ ] 待决策清单中每项都有2+可行方案
- [ ] P0功能点数量 ≤ 10个

#### 模板结构

**PRD文档模板**:
```markdown
# 产品需求文档 (PRD)

**项目名称**: [项目名称]
**迭代编号**: {id}
**文档版本**: v1.0.0
**创建日期**: YYYY-MM-DD
**生命周期阶段**: P1 - 需求定义

---

## 第一部分：需求原始输入
[用户的产品想法、背景、目标]

## 第二部分：功能规格框架
### 模块一：功能定义与拆解
[功能项、用户故事]

### 模块二：交互流程与规则
[业务流程、用户交互]

### 模块三：范围边界
[In-Scope / Out-of-Scope]

## 第三部分：AI分析与建议
### 建议的MVP功能点清单
[P0/P1/P2优先级标记]

### 待决策清单
[决策点、方案对比、推荐方案]
```

**功能点清单模板**:
```markdown
# 功能点清单

**迭代编号**: {id}
**创建日期**: YYYY-MM-DD
**生命周期阶段**: P1 - 需求定义

---

## 功能点列表

### [P0] 核心功能

#### F1.1 [功能名称]
- **需求来源**: [来源]
- **功能描述**: [描述]
- **用户输入**: [输入]
- **系统输出**: [输出]
- **关键约束**: [约束]
- **验收标准**: [标准]
- **依赖关系**: [依赖]
- **预估工时**: [工时]

### [P1] 重要功能

#### F2.1 [功能名称]
[同样结构]

### [P2] 增强功能

#### F3.1 [功能名称]
[同样结构]
```

#### 错误处理

**错误类型1: 产品想法描述过短**
```
错误: 产品想法描述至少需要20个字符
解决: 请提供更详细的产品想法描述
```

**错误类型2: MVP范围过大**
```
错误: P0功能点数量超过10个
解决: 请重新评估MVP范围，确保核心功能最小化
```

**错误类型3: 决策方案不足**
```
错误: 待决策清单中某项缺少可行方案
解决: 请为每个决策点提供至少2个可行方案
```

#### 输出示例

```markdown
✅ 需求定义完成

📋 PRD文档:
  路径: docs/iterations/001-my-feature/prd.md
  版本: v1.0.0

📋 功能点清单:
  路径: docs/iterations/001-my-feature/function-points.md
  P0功能: 3个
  P1功能: 2个
  P2功能: 1个

🔍 需要澄清的问题:
  [NEEDS CLARIFICATION: 用户认证方式选择]
  [NEEDS CLARIFICATION: 数据存储方案]

🔍 下一步:
  请使用 /powerby.clarify 指令开始需求澄清阶段
```

---

### 2.3 `/powerby.clarify` 指令

**指令描述**: 需求澄清和边界明确

#### 指令格式
```bash
/powerby.clarify [选项]
```

#### 选项参数
- `--prd-path`: PRD文档路径（可选，默认使用最新PRD）
- `--function-points-path`: 功能点清单路径（可选，默认使用最新功能点清单）
- `--questions`: 澄清问题数量（可选，默认最大5个）

#### 前置条件检查
- ✅ `/powerby.define` 已完成
- ✅ PRD文档存在
- ✅ 功能点清单已生成
- ✅ 当前阶段状态为 P1

#### 执行逻辑

**步骤1: 读取上下文文档**
```markdown
1. 读取PRD文档
2. 读取功能点清单
3. 检查文档完整性
```

**步骤2: 11大类覆盖度分析**
使用 `requirement-alignment` 技能分析以下11大类：
```markdown
1. 功能范围与边界
2. 数据模型与实体
3. 交互与UX流程
4. 非功能属性(性能/安全/可靠性)
5. 集成与外部依赖
6. 边界情况与失败处理
7. 约束与权衡
8. 术语一致性
9. 完整性信号
10. 待办项/占位符
```

**步骤3: 生成澄清问题清单**
基于覆盖度分析，生成最多5个高优先级澄清问题：
```markdown
问题 1: [问题描述]
- 重要性: [为什么必须澄清]
- 影响范围: [会影响哪些方面]

问题 2: ...
```

**步骤4: 结构化澄清**
针对每个问题：
```markdown
1. 提供推荐方案
2. 提供备选方案
3. 从MVP角度分析利弊
4. 明确推荐理由
```

**步骤5: 更新功能点清单**
将澄清结果同步回 `function-points.md`

**步骤6: 生成澄清记录**
使用 `templates/clarifications-template.md` 生成 `docs/iterations/{iter}-{name}/clarifications.md`

**步骤7: Gate 2检查**
执行以下检查：
- [ ] 11大类覆盖度分析已完成
- [ ] 高优先级模糊点已全部澄清(≤5个问题)
- [ ] 所有澄清已同步回prd.md对应章节
- [ ] 覆盖度状态: 核心类别≥80%为"Clear"

#### 模板结构

**澄清记录模板**:
```markdown
# 需求澄清记录

**迭代编号**: {id}
**创建日期**: YYYY-MM-DD
**生命周期阶段**: P2 - 需求澄清

---

## 澄清会话记录

### 日期: YYYY-MM-DD
**问题**: [问题描述]
**答案**: [用户回答]

## 覆盖度状态表
| 类别 | 状态 | 备注 |
|------|------|------|
| 功能范围与边界 | Clear | - |
| 数据模型与实体 | Needs Work | 需补充字段定义 |
| [其他类别...] | | |

## 遗留问题清单
- [ ] [未解决的问题]
```

#### 错误处理

**错误类型1: 覆盖度分析失败**
```
错误: 无法完成11大类覆盖度分析
解决: 请检查PRD文档和功能点清单的完整性
```

**错误类型2: 澄清问题过多**
```
错误: 高优先级澄清问题超过5个
解决: 请重新评估问题优先级，保留最重要的5个问题
```

**错误类型3: 核心类别清晰度不足**
```
错误: 核心类别清晰度低于80%
解决: 请继续澄清，直到核心类别清晰度达到80%以上
```

#### 输出示例

```markdown
✅ 需求澄清完成

📋 澄清记录:
  路径: docs/iterations/001-my-feature/clarifications.md
  澄清问题: 3个
  覆盖度分析: 11/11完成

📊 覆盖度状态:
  Clear: 9个类别
  Needs Work: 2个类别
  Unknown: 0个类别

📋 更新的文档:
  - function-points.md (已同步澄清结果)

🔍 下一步:
  请使用 /powerby.design 指令开始技术调研和架构设计阶段
```

---

### 2.4 `/powerby.design` 指令

**指令描述**: 技术调研和架构设计

#### 指令格式
```bash
/powerby.design [选项]
```

#### 选项参数
- `--prd-path`: PRD文档路径（可选，默认使用最新PRD）
- `--function-points-path`: 功能点清单路径（可选，默认使用最新功能点清单）
- `--clarifications-path`: 澄清记录路径（可选，默认使用最新澄清记录）

#### 前置条件检查
- ✅ `/powerby.clarify` 已完成
- ✅ PRD文档存在
- ✅ 功能点清单存在
- ✅ 澄清记录存在
- ✅ 当前阶段状态为 P2

#### 执行逻辑

**步骤1: 需求解读与目标对齐**
```markdown
1. 读取PRD、功能点清单、澄清记录
2. 提炼与复述核心目标
3. 识别关键功能点和技术约束
4. 寻求用户确认
```

**步骤2: 技术调研分析（P3）**
针对每个核心功能点，进行深度技术调研：
```markdown
1. 技术栈选型：前端、后端、数据库、缓存、中间件
2. 架构模式：单体/微服务/事件驱动/函数式等
3. 关键技术：第三方服务、SDK、API集成
4. 性能与扩展：并发处理、横向扩展、缓存策略
5. 安全与合规：认证授权、数据加密、合规要求
```

**步骤3: 生成技术调研报告**
使用 `templates/technical-research-template.md` 生成 `docs/iterations/{iter}-{name}/technical-research.md`

**步骤4: Gate 3检查**
执行以下检查：
- [ ] 所有P0功能的技术可行性已评估
- [ ] 核心技术选型已完成决策（至少1个备选方案）
- [ ] 关键技术风险已识别并有缓解措施
- [ ] 技术调研报告结构完整

**步骤5: 架构设计与可视化（P4）**
```markdown
1. 生成核心架构图（Mermaid）
2. 创建架构图说明（文字）
3. 建立组件与需求映射
4. 记录关键技术决策
```

**步骤6: 生成架构设计文档**
使用 `templates/architecture-template.md` 生成 `docs/iterations/{iter}-{name}/architecture.md`

**步骤7: Gate 4检查**
执行以下检查：
- [ ] 架构图清晰表达了系统结构
- [ ] 每个组件的职责明确且有需求映射
- [ ] 所有关键技术决策已完成并记录
- [ ] 架构设计符合PRD要求
- [ ] 非功能需求（性能、安全等）已考虑

#### 模板结构

**技术调研报告模板**:
```markdown
# 技术调研报告

**迭代编号**: {id}
**分支**: {branch-name}
**报告日期**: YYYY-MM-DD
**生命周期阶段**: P3 - 技术调研

---

## 1. 核心技术选型

### 前端技术栈
**方案A**: [技术名称]
- **适用场景**: [描述]
- **优势**: [列出优点]
- **风险**: [潜在风险]
- **MVP适用性**: [最适合/适合/不适合]

### 后端技术栈
[同样的结构]

### 数据存储方案
[同样的结构]

## 2. 关键技术决策点

### 决策点1: [决策主题]
**问题描述**:
```
[简明扼要描述需要决策的技术问题]
```

**逻辑阐述**:
- **为何重要**: [解释为什么这个决策重要]
- **影响范围**: [说明会影响哪些方面]

**备选方案**:

**方案A**: [方案名称]
- **描述**: [方案的具体内容]
- **实现复杂度**: [低/中/高]
- **优点**: ✅ [优点1] ✅ [优点2]
- **缺点**: ❌ [缺点1] ❌ [缺点2]
- **MVP适用性**: [最适合MVP / 适合MVP / 不适合MVP]

**方案B**: [方案名称]
[同样的结构]

**⭐ 推荐方案**: [方案A/B]
**推荐理由**: [从MVP角度分析]
```

**架构设计文档模板**:
```markdown
# [项目名称] 技术架构设计

**迭代编号**: {id}
**分支**: {branch-name}
**文档版本**: v1.0.0
**创建日期**: YYYY-MM-DD
**生命周期阶段**: P4 - 架构设计

---

## 1. 需求概述

### 1.1 核心业务目标
[从PRD提炼的核心业务目标]

### 1.2 关键功能点
- [P0] 功能点1: [描述]
- [P0] 功能点2: [描述]
- [P1] 功能点3: [描述]

### 1.3 关键用户流程
[用户流程描述]

## 2. 核心技术选型

### 2.1 前端技术栈
[技术选型及理由]

### 2.2 后端技术栈
[技术选型及理由]

### 2.3 数据存储方案
[技术选型及理由]

## 3. 核心架构设计

### 3.1 系统架构图
[Mermaid 图纸]

### 3.2 架构说明
[概念解读、组件职责、交互说明]

### 3.3 组件与需求映射
[清晰的可追溯性矩阵]

## 4. 关键技术决策

### 决策点1: [名称]
- **选定方案**: [方案名称]
- **决策日期**: YYYY-MM-DD
- **决策人**: [姓名]
- **理由**: [为什么选择此方案]
- **风险与缓解措施**: [潜在风险及应对策略]
- **后续影响**: [对未来迭代的影响]

### 决策点2: [名称]
[...]
```

#### 错误处理

**错误类型1: 技术可行性评估不足**
```
错误: 部分P0功能的技术可行性未评估
解决: 请完善技术调研，确保所有P0功能都有技术方案
```

**错误类型2: 架构图不清晰**
```
错误: 架构图无法清晰表达系统结构
解决: 请重新设计架构图，确保组件和关系清晰
```

**错误类型3: 组件需求映射缺失**
```
错误: 部分组件没有对应的需求映射
解决: 请为每个组件建立清晰的需求映射关系
```

#### 输出示例

```markdown
✅ 技术调研和架构设计完成

📋 技术调研报告:
  路径: docs/iterations/001-my-feature/technical-research.md
  技术选型: 已完成
  决策点: 5个

📋 架构设计文档:
  路径: docs/iterations/001-my-feature/architecture.md
  架构图: 已生成
  组件映射: 已完成

🔍 下一步:
  请使用 /powerby.implement 指令开始开发规划和实现阶段
```

---

### 2.5 `/powerby.implement` 指令

**指令描述**: 开发规划和实现

#### 指令格式
```bash
/powerby.implement [选项]
```

#### 选项参数
- `--prd-path`: PRD文档路径（可选，默认使用最新PRD）
- `--architecture-path`: 架构文档路径（可选，默认使用最新架构文档）
- `--tdd`: 启用TDD模式（可选，默认启用）

#### 前置条件检查
- ✅ `/powerby.design` 已完成
- ✅ PRD文档存在
- ✅ 架构设计文档存在
- ✅ 当前阶段状态为 P4

#### 执行逻辑

**步骤1: 需求与架构对齐分析**
```markdown
1. 读取PRD和架构文档
2. 提炼与复述核心目标
3. 识别关键功能点和技术约束
4. 明确开发范围和边界
```

**步骤2: 开发任务规划（P5）**
```markdown
1. 功能分解：基于P0/P1/P2优先级分解任务
2. 技术任务：架构组件实现、测试、开发环境等
3. 依赖关系：任务间的依赖和并行关系
4. 工作估算：每个任务的预估工时
5. 验收标准：每个任务的可验证标准
```

**步骤3: 生成开发任务计划**
使用 `templates/tasks-template.md` 生成 `docs/iterations/{iter}-{name}/tasks.md`

**步骤4: Gate 5检查**
执行以下检查：
- [ ] 所有P0功能都有对应的开发任务
- [ ] 任务分解粒度合适（1-2天可完成）
- [ ] 依赖关系清晰合理
- [ ] 验收标准可验证
- [ ] 工作量估算合理

**步骤5: TDD实现流程（P6）**
严格执行TDD循环：
```markdown
1. 红灯（Red）：编写失败的测试
2. 绿灯（Green）：编写最精简的代码，让测试通过
3. 重构（Refactor）：在测试的保护下，清理和优化代码
4. 提交（Commit）：小步提交，每次提交都可编译且通过测试
```

**步骤6: 主动式障碍解决协议**
当遇到技术障碍时：
```markdown
1. 立即停止当前实现
2. 分析障碍的根本原因
3. 尝试解决方案（最多3次）
4. 输出障碍解决报告
```

**步骤7: 生成实现报告**
使用 `templates/implementation-report-template.md` 生成 `docs/iterations/{iter}-{name}/implementation-report.md`

**步骤8: Gate 6检查**
执行以下检查：
- [ ] 所有P0任务已完成
- [ ] 测试用例全部通过
- [ ] 测试覆盖率达标（≥80%）
- [ ] 代码通过Linter检查
- [ ] 无严重安全漏洞
- [ ] 可追溯性矩阵完整

#### 模板结构

**开发任务计划模板**:
```markdown
# 开发任务计划

**迭代编号**: {id}
**分支**: {branch-name}
**创建日期**: YYYY-MM-DD
**生命周期阶段**: P5 - 开发规划

---

## 任务统计

| 优先级 | 任务数 | 预估总工时 |
|-------|-------|-----------|
| P0 | X个 | X小时 |
| P1 | X个 | X小时 |
| P2 | X个 | X小时 |
| **总计** | **X个** | **X小时** |

## 开发任务清单

### P0 核心功能 (Must Have)

#### TASK-{id}-001: [任务名称]
- **关联需求**: [prd.md中的需求点]
- **关联架构**: [architecture.md中的组件]
- **任务描述**: [详细描述要做什么]
- **验收标准**:
  - [ ] 标准1: [可验证的标准]
  - [ ] 标准2: [可验证的标准]
- **预估工时**: X小时
- **依赖关系**: [前置任务ID]
- **测试策略**: [单元测试/集成测试/端到端测试]
- **状态**: [待开始/进行中/已完成]

#### TASK-{id}-002: [任务名称]
[同样的结构...]

### P1 重要功能 (Should Have)

#### TASK-{id}-101: [任务名称]
[同样的结构...]

### P2 增强功能 (Could Have)

#### TASK-{id}-201: [任务名称]
[同样的结构...]

## 技术任务

### 环境搭建
- [ ] 开发环境配置
- [ ] CI/CD流水线设置
- [ ] 代码规范配置

### 基础设施
- [ ] 数据库迁移脚本
- [ ] API文档生成
- [ ] 监控和日志系统

## 开发里程碑

| 里程碑 | 包含任务 | 预计完成时间 | 验收标准 |
|-------|---------|------------|---------|
| M1: 核心功能完成 | TASK-001, TASK-002, ... | YYYY-MM-DD | [标准] |
| M2: 集成测试通过 | TASK-101, TASK-102, ... | YYYY-MM-DD | [标准] |
| M3: 文档和交付 | 所有任务 | YYYY-MM-DD | [标准] |

## 风险评估

### 高风险任务
- **任务**: [任务名称]
- **风险**: [描述风险]
- **缓解措施**: [应对策略]

### 技术依赖
- **依赖**: [第三方服务/库]
- **风险**: [潜在问题]
- **应对**: [解决方案]
```

**实现报告模板**:
```markdown
# 开发实现报告

**迭代编号**: {id}
**完成日期**: YYYY-MM-DD
**生命周期阶段**: P6 - 开发实现

---

## 1. 任务完成情况

| 任务ID | 任务名称 | 优先级 | 状态 | 实际工时 | 预估工时 | 差异 |
|-------|---------|-------|------|---------|---------|------|
| TASK-001 | [名称] | P0 | ✅完成 | X小时 | X小时 | ±X |
| TASK-002 | [名称] | P0 | ✅完成 | X小时 | X小时 | ±X |

## 2. 遵从性声明
我确认，本次交付的所有代码均严格遵循了在【P5阶段】批准的 **[方案名称]** 技术方案，未发生任何偏离。

## 3. 可追溯性矩阵

| 任务项 | 需求点 | 架构组件 | 测试用例ID |
|-------|-------|---------|-----------|
| [任务ID] | [prd.md需求] | [architecture.md组件] | [TC-001, TC-002] |

## 4. 测试执行结果
- 总测试用例数: X
- 通过: X
- 失败: 0
- 覆盖率: X%
- 单元测试覆盖率: X%
- 集成测试覆盖率: X%

## 5. 代码质量指标
- 代码复杂度: [平均复杂度]
- 代码重复率: X%
- 技术债务: [评估]

## 6. 代码交付物
[列出所有新增或修改的文件路径]

## 7. 文档更新
- [ ] API文档已更新
- [ ] 部署文档已更新
- [ ] 开发者文档已更新

## 8. 后续建议
[对后续迭代的建议和注意事项]
```

#### 错误处理

**错误类型1: 任务分解粒度不合适**
```
错误: 部分任务分解粒度过大（超过2天工作量）
解决: 请重新分解任务，确保每个任务在1-2天内完成
```

**错误类型2: 测试覆盖率不达标**
```
错误: 测试覆盖率低于80%
解决: 请补充测试用例，确保覆盖率达标
```

**错误类型3: 遇到技术障碍**
```
错误: 遇到无法解决的技术障碍
解决: 请启动主动式障碍解决协议，提供至少2个备选方案
```

#### 输出示例

```markdown
✅ 开发规划和实现完成

📋 开发任务计划:
  路径: docs/iterations/001-my-feature/tasks.md
  P0任务: 5个
  P1任务: 3个
  P2任务: 2个

📋 实现报告:
  路径: docs/iterations/001-my-feature/implementation-report.md
  任务完成: 5/5 (P0)
  测试覆盖率: 85%
  代码质量: 通过

🔍 下一步:
  请使用 /powerby.review 指令开始代码审查和交付阶段
```

---

### 2.6 `/powerby.review` 指令

**指令描述**: 代码审查和交付

#### 指令格式
```bash
/powerby.review [选项]
```

#### 选项参数
- `--prd-path`: PRD文档路径（可选，默认使用最新PRD）
- `--function-points-path`: 功能点清单路径（可选，默认使用最新功能点清单）
- `--architecture-path`: 架构文档路径（可选，默认使用最新架构文档）
- `--tasks-path`: 任务计划路径（可选，默认使用最新任务计划）
- `--implementation-report-path`: 实现报告路径（可选，默认使用最新实现报告）
- `--pr-link`: Pull Request链接（可选）

#### 前置条件检查
- ✅ `/powerby.implement` 已完成
- ✅ PRD文档存在
- ✅ 功能点清单存在
- ✅ 架构文档存在
- ✅ 任务计划存在
- ✅ 实现报告存在
- ✅ 当前阶段状态为 P6

#### 执行逻辑

**步骤1: 接收上下文信息**
```markdown
1. 请求用户提供所有必需的文档路径
2. 使用 Read 工具读取这些文档
3. 请求PR信息（链接、分支名称、或代码变更内容）
```

**步骤2: 执行5大类审查清单**

**1. 一致性与范围审计**
```markdown
- [ ] 代码实现的功能点，是否与 function-points.md 中的P0功能点完全一致？
- [ ] 每个P0功能点的验收标准是否都已满足？
- [ ] 功能点的8要素是否都已在实现中得到体现？
- [ ] 是否存在 function-points.md 中未定义的功能实现？
- [ ] 代码实现的功能，是否严格且完整地对应了 tasks.md 中本次迭代的任务？
- [ ] 实现方式是否完全遵循了 architecture.md 中定义的组件职责和设计？
- [ ] 最终实现的功能点，是否与 prd.md 中的 P0 需求完全一致？
- [ ] 是否存在任何计划外的功能、重构或"镀金"行为？
```

**2. 实现完整性与真实性审计**
```markdown
- [ ] 代码中是否存在任何"假实现"？
  - 返回硬编码数据
  - 空的函数体
  - 带有 `// TODO: implement later` 注释的占位逻辑
- [ ] 所有被调用的内部函数或方法，是否都已被完整实现？
- [ ] 禁止存在任何对未实现函数的调用
- [ ] 所有业务逻辑是否都基于真实的数据流和计算，而非编造的数据？
```

**3. 设计哲学与代码质量审计**
```markdown
**SOLID 原则**:
- [ ] 单一职责：每个类/函数是否只做一件事？
- [ ] 开放封闭：是否易于扩展，不需要修改现有代码？
- [ ] 其他原则是否得到体现？

**KISS（Keep It Simple）**:
- [ ] 代码是否选择了最简单、最- [ ] 是否直接的实现方式？
避免了过早的抽象和不必要的复杂性？

**DRY（Don't Repeat Yourself）**:
- [ ] 是否存在重复的代码逻辑？
- [ ] 通用逻辑是否被抽象为可复用的组件？

**代码可读性**:
- [ ] 命名是否清晰、有意义？
- [ ] 是否存在魔法数字？
- [ ] 注释是否得当（只在必要时注释"为什么"，而非"是什么"）？
- [ ] 代码结构是否易于理解？

**最小影响面**:
- [ ] 代码修改是否控制在最小范围？
- [ ] 是否避免了不必要的重构？
```

**4. 测试与健壮性审计**
```markdown
- [ ] 是否提交了自动化测试（单元/集成测试）？
- [ ] 测试是否充分覆盖了核心逻辑？
- [ ] 测试是否遵循了 TDD 的最佳实践？
- [ ] 测试是否是确定性的（无随机或不稳定的结果）？

**错误处理**:
- [ ] 错误处理是否恰当？
- [ ] 是否存在吞噬异常的情况？
- [ ] 是否向上抛出不明确的异常？
- [ ] 错误信息是否包含调试上下文？

**安全性**:
- [ ] 代码是否存在明显的安全漏洞（OWASP Top 10）？
- [ ] 是否存在SQL注入、XSS、命令注入等风险？
```

**5. 提交质量审计**
```markdown
- [ ] 提交信息是否清晰解释了"为什么"要这么做？
- [ ] 是否进行了小步提交？
- [ ] 每次提交是否都可编译且通过测试？
- [ ] 是否关联到开发计划或任务ID？
```

**步骤3: 生成审计报告**
使用 `templates/code-review-report-template.md` 生成 `docs/iterations/{iter}-{name}/code-review-report.md`

**步骤4: Gate 7检查**
执行以下检查：
- [ ] 所有5大类审计项已完成检查
- [ ] **功能点一致性验证已完成**
- [ ] 所有P0功能点的验收标准都已满足
- [ ] 最终结论明确（APPROVED或CHANGES REQUESTED）
- [ ] 可追溯性矩阵验证完成
- [ ] 功能验收方案已提供

**步骤5: 生成交付报告（P8）**
如果Gate 7通过，使用 `templates/delivery-report-template.md` 生成 `docs/iterations/{iter}-{name}/delivery-report.md`

**步骤6: Gate 8检查**
执行以下检查：
- [ ] 所有交付物清单已完成
- [ ] 所有P0功能已实现并通过测试
- [ ] 代码已合并到主干分支
- [ ] 文档完整且最新
- [ ] 部署流程已验证

#### 模板结构

**审计报告模板**:
```markdown
# 代码审计报告

**迭代编号**: {id}
**分支**: {branch-name}
**审查日期**: YYYY-MM-DD
**生命周期阶段**: P7 - 代码审查

---

## 1. 最终结论（Final Verdict）

**[APPROVED]** 或 **[CHANGES REQUESTED]**

（必须二选一。只有当所有审计项都完美通过时，才能给出 [APPROVED]）

## 2. 总体评价（Overall Assessment）

[用1-2句话总结本次代码变更在"一致性、完整性、质量"三个方面的表现]

## 3. 功能实现与验收方案（Feature Completion & Acceptance Plan）

### A. 功能点完成情况（Function Point Completion Status）

基于 function-points.md 中定义的功能点，列出实现完成情况：

| 功能点ID | 功能点名称 | 优先级 | 完成状态 | 实现位置 | 验收状态 |
|---------|-----------|-------|---------|---------|---------|
| F1.1 | 单DEX价格查询 | P0 | ✅ 已完成 | [文件路径:行号] | ✅ 通过 |
| F1.2 | 多DEX并行聚合 | P0 | ✅ 已完成 | [文件路径:行号] | ✅ 通过 |
| F2.1 | 手续费率获取 | P0 | ✅ 已完成 | [文件路径:行号] | ✅ 通过 |
| ... | ... | ... | ... | ... | ... |

**功能点验证结果**: [✅ 所有P0功能点已完成 / ⚠️ 部分功能点未完成 / ❌ 核心功能点缺失]

### B. 已完成功能列表（List of Completed Features）

清晰列出此PR所完成的用户可见或系统核心功能点：

- 功能点1: [例如：实现了从Uniswap V3获取ETH/USDC的实时价格]
- 功能点2: [例如：实现了基于0.3%手续费的价格计算逻辑]
- ...

### C. 建议测试方案（Recommended Testing Plan）

为上述每一个功能点，提供一个简单、可执行的手动测试方案。

#### 测试功能点1：实时价格获取

**测试目的**: 验证系统能从链上获取并展示正确的价格

**前置条件**: 无

**测试步骤**:
1. 调用 getPrice API，参数为 token_in=ETH, token_out=USDC
2. 在浏览器中打开Etherscan或CoinGecko，查询当前ETH/USDC的实时价格

**预期结果**: API返回的价格与市场公开价格的误差在2%以内

## 4. 一致性与可追溯性验证（Traceability Verification）

| function-points.md 功能点 | tasks.md 任务项 | prd.md 需求 | architecture.md 组件 | 代码实现位置 | 测试覆盖 |
|--------------------------|----------------|------------|---------------------|------------|---------|
| [功能点ID] | [任务ID] | [需求点] | [组件名称] | [文件路径:行号] | [测试文件] |

**验证结果**: [✅ 完全一致 / ⚠️ 存在偏差 / ❌ 不一致]

## 5. 详细修改建议（Detailed Change Requests List）

如果结论是 [CHANGES REQUESTED]，请在此处按严重性列出所有需要修改的问题。

### [Critical] 关键问题（必须修复）

**问题1**:
- **文件**: path/to/file.py, 行号: XX
- **问题描述**: [例如："此处的汇率直接硬编码为1500，未调用真实的喂价服务，违反了'实现真实性'原则。"]
- **违反的原则**: 实现真实性、文档驱动
- **修复建议**: [例如："请删除硬编码值，并集成已在architecture.md中定义的PriceOracle服务来获取数据。"]

### [Major] 主要问题（建议修复）

**问题1**:
- **文件**: ...
- **问题描述**: ...
- **违反的原则**: ...
- **修复建议**: ...

### [Minor] 次要问题/代码风格

**问题1**:
- **文件**: ...
- **问题描述**: ...
- **修复建议**: ...

## 6. 优秀实践亮点（Good Practices Highlights）

[如果有值得称赞的实现，在此处列出]

- 亮点1: [描述]
- 亮点2: [描述]

## 7. 审计摘要统计（Audit Summary Statistics）

- **审计项总数**: [X]
- **通过**: [X]
- **需要改进**: [X]
- **严重问题**: [X]
- **建议结论**: [APPROVED / CHANGES REQUESTED]
```

**交付报告模板**:
```markdown
# 项目交付报告

**迭代编号**: {id}
**项目名称**: [项目名称]
**交付日期**: YYYY-MM-DD
**生命周期阶段**: P8 - 交付

---

## 1. 项目概述

### 1.1 项目目标
[从PRD中提炼的项目目标]

### 1.2 核心功能
- [P0] 功能1: [描述]
- [P0] 功能2: [描述]
- [P1] 功能3: [描述]

### 1.3 技术架构
[简要描述技术栈和架构]

## 2. 交付清单

### 2.1 代码交付
- **代码仓库**: [仓库地址]
- **主干分支**: main
- **代码行数**: [总行数]
- **测试覆盖率**: [X%]
- **关键组件**: [列出主要组件]

### 2.2 文档交付
- [ ] PRD文档 (prd.md)
- [ ] 架构文档 (architecture.md)
- [ ] 实现报告 (implementation-report.md)
- [ ] 审查报告 (code-review-report.md)
- [ ] API文档
- [ ] 部署指南
- [ ] 运维手册

### 2.3 部署信息
- **部署环境**: [环境名称]
- **部署方式**: [自动化/手动]
- **监控配置**: [监控工具]
- **日志配置**: [日志系统]

## 3. 质量指标

### 3.1 代码质量
- **测试覆盖率**: [X%]
- **代码复杂度**: [评估]
- **代码重复率**: [X%]
- **安全漏洞**: [数量/状态]

### 3.2 性能指标
- **响应时间**: [指标]
- **吞吐量**: [指标]
- **可用性**: [指标]

## 4. 项目成果

### 4.1 已完成功能
[列出所有已完成的功能]

### 4.2 待优化项目
[列出可以后续优化的项目]

## 5. 经验总结

### 5.1 成功经验
[总结成功的做法]

### 5.2 改进建议
[提出改进建议]

### 5.3 风险提示
[列出需要注意的风险]

## 6. 后续建议

### 6.1 短期优化 (1-2周)
- [ ] 优化项目1
- [ ] 优化项目2

### 6.2 中期规划 (1-2月)
- [ ] 功能1
- [ ] 功能2

### 6.3 长期发展 (3-6月)
- [ ] 规划1
- [ ] 规划2

## 7. Gate 8 检查结果

### 检查清单
- [x] 所有P0功能已实现并通过测试
- [x] 代码已合并到主干分支
- [x] 文档完整且最新
- [x] 部署流程已验证
- [x] 监控和日志已配置

**Gate 8 检查结果**: ✅ **通过** - 项目正式完成

---

**项目状态**: ✅ 已完成
**交付日期**: YYYY-MM-DD
**负责人**: [姓名]
```

#### 错误处理

**错误类型1: 功能点一致性验证失败**
```
错误: 代码实现与功能点清单不一致
解决: 请修改代码，确保与功能点清单完全一致
```

**错误类型2: 发现假实现**
```
错误: 发现硬编码、占位符或TODO注释
解决: 请删除所有假实现，提供真实的代码
```

**错误类型3: 测试覆盖率不足**
```
错误: 测试覆盖率低于80%
解决: 请补充测试用例，确保覆盖率达标
```

#### 输出示例

```markdown
✅ 代码审查完成

📋 审计报告:
  路径: docs/iterations/001-my-feature/code-review-report.md
  结论: APPROVED
  审计项: 45/45通过

📋 交付报告:
  路径: docs/iterations/001-my-feature/delivery-report.md
  项目状态: ✅ 已完成

🎉 项目交付完成
  所有P0功能已实现并通过测试
  代码已合并到主干分支
  文档完整且最新
```

---

## 三、指令执行规则

### 3.1 通用执行流程

所有指令都遵循以下通用执行流程：

```markdown
1. 输入验证
2. 前置条件检查
3. 读取上下文文档
4. 执行指令逻辑
5. 质量门禁检查
6. 生成输出文档
7. 更新项目元数据
```

### 3.2 错误处理原则

1. **快速失败**：遇到错误立即停止并报告
2. **明确错误信息**：提供清晰的错误描述和解决方案
3. **重试机制**：允许用户修正错误后重试
4. **升级机制**：连续失败时提供升级选项

### 3.3 日志记录

所有指令执行过程都需要记录日志：

```markdown
[时间] [指令] 开始执行
[时间] [指令] 步骤1完成
[时间] [指令] 步骤2完成
...
[时间] [指令] 执行完成
```

---

## 四、总结

PowerBy指令详细定义提供了完整的指令实现方案，包括：

1. **指令格式和参数**：明确的命令行格式和参数说明
2. **前置条件检查**：确保指令执行的前置条件满足
3. **执行逻辑**：详细的步骤和决策逻辑
4. **模板结构**：标准化的文档模板
5. **错误处理**：完整的错误类型和处理方案
6. **输出示例**：清晰的输出格式和示例

通过这些详细的指令定义，PowerBy-skills能够将松散的对话式开发流程转化为结构化的开发流水线，提高开发效率和交付质量。
