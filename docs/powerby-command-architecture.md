# PowerBy 指令流程架构设计

**版本**: v1.0.0
**设计日期**: 2025-12-18
**基于**: PowerBy生命周期框架 + Spec-kit约束机制

---

## 一、设计理念与约束原则

### 1.1 核心设计理念

PowerBy指令流程架构的设计目标是将松散的对话式开发流程转化为**结构化的开发流水线**，通过以下三层约束机制确保流程闭环：

1. **强制阶段门禁**（Phase Gates）：确保前置条件满足
2. **结构化模板**（Templates）：标准化输出格式和质量
3. **质量验证**（Quality Checks）：防止低质量交付进入下一阶段

### 1.2 约束机制核心要素

借鉴spec-kit的成功经验，PowerBy指令流程的核心约束机制包括：

#### A. 强制性命令序列
- 严格的阶段依赖关系（前一阶段完成后才能进入下一阶段）
- 每阶段都有明确的输入条件和输出要求
- 阶段间通过标准化文档进行信息传递

#### B. 模板驱动的结构化约束
- 每个阶段都有对应的模板结构
- 模板中包含必填字段和验证检查点
- 模板确保输出信息的完整性和一致性

#### C. 质量门禁系统
- 每阶段结束时进行Gate检查
- Gate失败时必须记录原因并改进
- 严格的验收标准防止低质量交付

#### D. 零假设原则执行
- 强制标记 `[NEEDS CLARIFICATION]`
- 限制澄清问题的数量（最多3个）
- 明确优先级：范围 > 安全/隐私 > 用户体验 > 技术细节

#### E. 任务依赖和并行标记
- `[P]` 标记可并行执行的任务
- 明确依赖关系和执行顺序
- 任务粒度足够小（单一职责）

---

## 二、PowerBy指令流程架构

### 2.1 指令序列总览

PowerBy指令流程采用 **"角色驱动 + 阶段推进"** 的模式，将P0-P8生命周期映射为6个核心指令：

```text
/powerby.initialize → /powerby.define → /powerby.clarify → /powerby.design → /powerby.implement → /powerby.review
```

**每个指令对应PowerBy生命周期阶段：**

| 指令名称 | 对应阶段 | 负责角色 | 主要职责 |
|---------|---------|---------|---------|
| `/powerby.initialize` | P0 | Product | 项目初始化和宪章建立 |
| `/powerby.define` | P1 | Product | 需求定义和功能点清单 |
| `/powerby.clarify` | P2 | Product | 需求澄清和边界明确 |
| `/powerby.design` | P3-P4 | Architect | 技术调研和架构设计 |
| `/powerby.implement` | P5-P6 | Engineer | 开发规划和实现 |
| `/powerby.review` | P7-P8 | Code Review | 代码审查和交付 |

### 2.2 指令流程图

```mermaid
graph TD
    A[用户启动] --> B[/powerby.initialize]
    B --> C{项目宪章完成?}
    C -->|是| D[/powerby.define]
    C -->|否| B

    D --> E{PRD和功能点清单完成?}
    E -->|是| F[/powerby.clarify]
    E -->|否| D

    F --> G{需求澄清完成?}
    G -->|是| H[/powerby.design]
    G -->|否| F

    H --> I{架构设计完成?}
    I -->|是| J[/powerby.implement]
    I -->|否| H

    J --> K{开发实现完成?}
    K -->|是| L[/powerby.review]
    K -->|否| J

    L --> M{项目交付完成?}
    M -->|是| N[项目完成]
    M -->|否| L

    style A fill:#e1f5fe
    style N fill:#c8e6c9
    style B fill:#fff3e0
    style D fill:#fff3e0
    style F fill:#fff3e0
    style H fill:#f3e5f5
    style J fill:#e8f5e8
    style L fill:#fce4ec
```

### 2.3 指令依赖关系

每个指令都有严格的前置条件：

1. **`/powerby.define`** 的前置条件：
   - ✅ `/powerby.initialize` 已完成
   - ✅ 项目宪章已创建
   - ✅ 当前阶段状态为 P0

2. **`/powerby.clarify`** 的前置条件：
   - ✅ `/powerby.define` 已完成
   - ✅ PRD文档已创建
   - ✅ 功能点清单已生成
   - ✅ 当前阶段状态为 P1

3. **`/powerby.design`** 的前置条件：
   - ✅ `/powerby.clarify` 已完成
   - ✅ 需求澄清记录已创建
   - ✅ 所有Gate检查已通过
   - ✅ 当前阶段状态为 P2

4. **`/powerby.implement`** 的前置条件：
   - ✅ `/powerby.design` 已完成
   - ✅ 架构设计文档已创建
   - ✅ 技术调研报告已完成
   - ✅ 当前阶段状态为 P4

5. **`/powerby.review`** 的前置条件：
   - ✅ `/powerby.implement` 已完成
   - ✅ 实现报告已创建
   - ✅ 所有开发任务已完成
   - ✅ 当前阶段状态为 P6

---

## 三、各阶段指令详细设计

### 3.1 `/powerby.initialize` 指令

**对应阶段**: P0 - 项目初始化
**职责**: 建立项目宪章和基础设施
**输入**: 项目基本信息
**输出**: 项目宪章、目录结构、元数据

#### 指令模板结构

```markdown
## /powerby.initialize 指令模板

### 输入要求
- 项目名称
- 项目描述
- 团队成员
- 技术偏好（可选）

### 核心执行步骤
1. 创建项目结构
2. 编写项目宪章
3. 初始化Git仓库
4. 更新项目元数据

### 质量门禁（Gate 0）
- [ ] 项目宪章包含所有必需章节
- [ ] 目录结构符合PowerBy规范
- [ ] Git仓库已初始化
- [ ] 元数据文件已创建

### 输出文档
- docs/constitution.md - 项目宪章
- .powerby/project.json - 项目元数据
```

#### 约束机制

**强制检查点**：
- 项目宪章必须包含核心理念、技术标准、工作流程、质量门禁等章节
- 目录结构必须符合PowerBy规范
- 必须创建Git仓库和初始提交

**质量验证**：
- 检查宪章完整性
- 验证目录结构
- 确保Git仓库初始化

### 3.2 `/powerby.define` 指令

**对应阶段**: P1 - 需求定义
**职责**: 将产品想法转化为清晰的功能点清单
**输入**: 产品想法和目标
**输出**: PRD文档、功能点清单

#### 指令模板结构

```markdown
## /powerby.define 指令模板

### 输入要求
- 产品想法描述
- 目标用户群体
- 核心业务问题
- 预期上线时间
- 特殊约束条件

### 核心执行步骤
1. 需求原始输入收集
2. MVP功能分解
3. 功能点优先级标记
4. 生成功能点清单
5. Gate 1检查

### 质量门禁（Gate 1）
- [ ] MVP核心价值已用一句话定义
- [ ] 所有功能点已标记优先级([P0]/[P1]/[P2])
- [ ] 范围边界已明确(In-Scope / Out-of-Scope)
- [ ] 待决策清单中每项都有2+可行方案
- [ ] P0功能点数量 ≤ 10个

### [NEEDS CLARIFICATION] 限制
- 最多3个澄清问题
- 优先级：范围 > 安全/隐私 > 用户体验 > 技术细节

### 输出文档
- docs/iterations/{id}-{name}/prd.md - 产品需求文档
- docs/iterations/{id}-{name}/function-points.md - 功能点清单文档
```

#### 约束机制

**MVP优先原则**：
- 必须识别核心价值并用一句话定义
- 无情地削减非必要功能
- 明确标记可推迟的功能项

**零假设原则**：
- 强制标记 `[NEEDS CLARIFICATION]`
- 限制澄清问题数量
- 优先级明确

**功能点清单**：
- 使用 `function-point-checker` 技能生成
- 确保"一个功能迭代同一份文档只有一份"原则

### 3.3 `/powerby.clarify` 指令

**对应阶段**: P2 - 需求澄清
**职责**: 通过结构化提问消除需求模糊性
**输入**: PRD文档和功能点清单
**输出**: 需求澄清记录

#### 指令模板结构

```markdown
## /powerby.clarify 指令模板

### 输入要求
- prd.md 文档路径
- function-points.md 文档路径
- 当前阶段状态为 P1

### 核心执行步骤
1. 基于功能点清单澄清
2. 11大类覆盖度分析
3. 生成澄清问题清单
4. 结构化澄清
5. Gate 2检查

### 质量门禁（Gate 2）
- [ ] 11大类覆盖度分析已完成
- [ ] 高优先级模糊点已全部澄清(≤5个问题)
- [ ] 所有澄清已同步回prd.md对应章节
- [ ] 覆盖度状态: 核心类别≥80%为"Clear"

### 输出文档
- docs/iterations/{id}-{name}/clarifications.md - 需求澄清记录
- 更新的function-points.md
```

#### 约束机制

**分类扫描**：
- 11大类覆盖度分析
- 明确每个类别的状态（Clear/Needs Work/Unknown）

**澄清问题控制**：
- 最多5个高优先级澄清问题
- 每个问题必须提供推荐方案和备选方案
- 从MVP角度分析利弊

**文档一致性**：
- 确保所有澄清都同步回原文档
- 保持"单一文档维护"原则

### 3.4 `/powerby.design` 指令

**对应阶段**: P3-P4 - 技术调研和架构设计
**职责**: 将需求转化为清晰的技术架构
**输入**: PRD、功能点清单、澄清记录
**输出**: 技术调研报告、架构设计文档

#### 指令模板结构

```markdown
## /powerby.design 指令模板

### 输入要求
- prd.md 文档路径
- function-points.md 文档路径
- clarifications.md 文档路径
- 当前阶段状态为 P2

### 核心执行步骤
1. 需求解读与目标对齐
2. 技术调研分析（P3）
3. Gate 3检查
4. 架构设计与可视化（P4）
5. Gate 4检查

### 质量门禁（Gate 3）
- [ ] 所有P0功能的技术可行性已评估
- [ ] 核心技术选型已完成决策（至少1个备选方案）
- [ ] 关键技术风险已识别并有缓解措施
- [ ] 技术调研报告结构完整

### 质量门禁（Gate 4）
- [ ] 架构图清晰表达了系统结构
- [ ] 每个组件的职责明确且有需求映射
- [ ] 所有关键技术决策已完成并记录
- [ ] 架构设计符合PRD要求
- [ ] 非功能需求（性能、安全等）已考虑

### 输出文档
- docs/iterations/{id}-{name}/technical-research.md - 技术调研报告
- docs/iterations/{id}-{name}/architecture.md - 技术架构设计文档
```

#### 约束机制

**忠于需求原则**：
- 所有设计必须基于PRD功能点清单
- 严禁新增或修改未明确的需求
- 每个架构组件必须有对应的需求点

**技术决策记录**：
- 所有关键技术决策必须有明确理由
- 必须提供至少2个方案供选择
- 从MVP角度分析利弊

**可追溯性**：
- 组件与需求映射必须清晰
- 每个决策都要有记录

### 3.5 `/powerby.implement` 指令

**对应阶段**: P5-P6 - 开发规划和实现
**职责**: 基于架构文档进行开发实现
**输入**: PRD、架构设计、任务计划
**输出**: 开发任务计划、实现报告

#### 指令模板结构

```markdown
## /powerby.implement 指令模板

### 输入要求
- prd.md 文档路径
- architecture.md 文档路径
- 当前阶段状态为 P4

### 核心执行步骤
1. 需求与架构对齐分析
2. 开发任务规划（P5）
3. Gate 5检查
4. TDD实现流程（P6）
5. Gate 6检查

### 质量门禁（Gate 5）
- [ ] 所有P0功能都有对应的开发任务
- [ ] 任务分解粒度合适（1-2天可完成）
- [ ] 依赖关系清晰合理
- [ ] 验收标准可验证
- [ ] 工作量估算合理

### 质量门禁（Gate 6）
- [ ] 所有P0任务已完成
- [ ] 测试用例全部通过
- [ ] 测试覆盖率达标（≥80%）
- [ ] 代码通过Linter检查
- [ ] 无严重安全漏洞
- [ ] 可追溯性矩阵完整

### 输出文档
- docs/iterations/{id}-{name}/tasks.md - 开发任务计划
- docs/iterations/{id}-{name}/implementation-report.md - 开发实现报告
```

#### 约束机制

**TDD强制执行**：
- 红灯（编写失败的测试）
- 绿灯（编写最精简的代码）
- 重构（在测试保护下优化）
- 提交（小步提交，确保可编译）

**文档驱动开发**：
- 所有工作必须严格基于提供的文档
- 严禁实现文档外的任何功能
- 保持可追溯性矩阵的完整性

**主动式障碍解决协议**：
- 遇到障碍时立即启动解决协议
- 提供至少2个备选方案
- 主动分析并提出建议

### 3.6 `/powerby.review` 指令

**对应阶段**: P7-P8 - 代码审查和交付
**职责**: 确保代码质量和流程闭环
**输入**: 代码变更、实现报告、文档
**输出**: 审计报告、交付报告

#### 指令模板结构

```markdown
## /powerby.review 指令模板

### 输入要求
- prd.md 文档路径
- function-points.md 文档路径
- architecture.md 文档路径
- tasks.md 文档路径
- implementation-report.md 文档路径
- Pull Request信息

### 核心执行步骤
1. 接收上下文信息
2. 执行5大类审查清单
3. Gate 7检查
4. 生成审计报告
5. Gate 8检查

### 5大类审查清单
1. 一致性与范围审计
2. 实现完整性与真实性审计
3. 设计哲学与代码质量审计
4. 测试与健壮性审计
5. 提交质量审计

### 质量门禁（Gate 7）
- [ ] 所有5大类审计项已完成检查
- [ ] 所有P0功能点的验收标准都已满足
- [ ] 最终结论明确（APPROVED或CHANGES REQUESTED）
- [ ] 可追溯性矩阵验证完成
- [ ] 功能验收方案已提供

### 质量门禁（Gate 8）
- [ ] 所有交付物清单已完成
- [ ] 所有P0功能已实现并通过测试
- [ ] 代码已合并到主干分支
- [ ] 文档完整且最新
- [ ] 部署流程已验证

### 输出文档
- docs/iterations/{id}-{name}/code-review-report.md - 代码审计报告
- docs/iterations/{id}-{name}/delivery-report.md - 项目交付报告
```

#### 约束机制

**5大类审计清单**：
- 一致性与范围审计
- 实现完整性与真实性审计
- 设计哲学与代码质量审计
- 测试与健壮性审计
- 提交质量审计

**绝不妥协的红线**：
- 假实现（硬编码、占位符、TODO注释）
- 功能不完整
- 偏离架构
- 缺少测试
- 安全漏洞
- 计划外功能

**功能点验证**：
- 基于function-points.md验证功能实现
- 确保所有P0功能点都已正确实现
- 建立从需求到实现的完整追踪链路

---

## 四、质量门禁系统设计

### 4.1 门禁检查原则

PowerBy指令流程的质量门禁系统借鉴spec-kit的Constitution Gates理念，为每个阶段设计严格的验收标准：

#### Gate 0: 项目初始化检查（P0→P1）
- 项目宪章完整性
- 目录结构规范性
- Git仓库初始化状态
- 元数据文件创建

#### Gate 1: MVP范围确认（P1→P2）
- MVP核心价值定义
- 功能点优先级标记
- 范围边界明确性
- 决策方案完整性
- P0功能点数量控制

#### Gate 2: 澄清完整性检查（P2→P3）
- 11大类覆盖度分析完成
- 高优先级模糊点澄清
- 文档一致性验证
- 核心类别清晰度达标

#### Gate 3: 技术调研完整性检查（P3→P4）
- P0功能技术可行性评估
- 核心技术选型决策
- 关键技术风险识别
- 调研报告结构完整性

#### Gate 4: 架构方案评审（P4→P5）
- 架构图清晰性
- 组件职责明确性
- 组件与需求映射
- 技术决策记录完整性
- 非功能需求考虑

#### Gate 5: 开发规划完整性检查（P5→P6）
- P0功能任务覆盖
- 任务分解粒度合适
- 依赖关系清晰性
- 验收标准可验证性
- 工作量估算合理性

#### Gate 6: 开发完成度检查（P6→P7）
- P0任务完成状态
- 测试用例通过率
- 测试覆盖率达标
- 代码质量检查
- 安全漏洞检查
- 可追溯性矩阵完整性

#### Gate 7: 代码审查完整性检查（P7→P8）
- 5大类审计项完成
- P0功能验收标准满足
- 最终结论明确性
- 可追溯性矩阵验证
- 功能验收方案提供

#### Gate 8: 交付验收检查（P8→完成）
- 交付物清单完成
- P0功能实现验证
- 代码合并状态
- 文档完整性
- 部署流程验证

### 4.2 门禁失败处理机制

当Gate检查失败时，必须遵循以下流程：

1. **记录失败原因**：
   - 明确列出未通过的检查项
   - 详细描述问题所在
   - 提供具体的改进建议

2. **制定改进计划**：
   - 针对每个失败项制定改进措施
   - 估算改进所需时间
   - 明确责任人

3. **重新检查**：
   - 改进完成后重新执行Gate检查
   - 验证所有检查项都已通过
   - 更新项目元数据

4. **升级机制**：
   - 如果连续3次Gate检查失败
   - 必须向上级汇报并寻求指导
   - 重新评估项目可行性

---

## 五、模板系统设计

### 5.1 模板分类

PowerBy指令流程的模板系统分为四类：

#### A. 初始化模板
- 项目宪章模板
- 目录结构模板
- 元数据模板

#### B. 产品模板
- PRD文档模板
- 功能点清单模板
- 需求澄清记录模板

#### C. 技术模板
- 技术调研报告模板
- 架构设计文档模板
- 开发任务计划模板

#### D. 质量模板
- 审计报告模板
- 交付报告模板
- 检查清单模板

### 5.2 模板约束机制

#### 必填字段标记
- 使用 `[必填]` 标记必须填写的字段
- 使用 `[可选]` 标记可选字段
- 使用 `[NEEDS CLARIFICATION]` 标记需要澄清的字段

#### 结构化格式
- 统一的章节结构
- 明确的层次关系
- 一致的标记格式

#### 验证规则
- 字段长度限制
- 格式规范检查
- 内容完整性验证

---

## 六、实施建议

### 6.1 分阶段实施

考虑到PowerBy指令流程的复杂性，建议分阶段实施：

#### 第一阶段：基础框架
1. 实现 `/powerby.initialize` 和 `/powerby.define` 指令
2. 建立基础模板系统
3. 实现Gate 0和Gate 1检查

#### 第二阶段：需求管理
1. 实现 `/powerby.clarify` 指令
2. 完善功能点清单系统
3. 实现Gate 2检查

#### 第三阶段：技术设计
1. 实现 `/powerby.design` 指令
2. 建立架构文档系统
3. 实现Gate 3和Gate 4检查

#### 第四阶段：开发实现
1. 实现 `/powerby.implement` 指令
2. 建立任务管理系统
3. 实现Gate 5和Gate 6检查

#### 第五阶段：质量保证
1. 实现 `/powerby.review` 指令
2. 建立审计报告系统
3. 实现Gate 7和Gate 8检查

### 6.2 工具支持

#### CLI工具
- 指令解析器
- 模板生成器
- 门禁检查器

#### 文档工具
- 模板编辑器
- 文档验证器
- 依赖关系追踪器

#### 集成工具
- Git集成
- IDE集成
- CI/CD集成

---

## 七、总结

PowerBy指令流程架构通过借鉴spec-kit的成功经验，建立了完整的约束机制，确保开发流程的闭环和质量。主要特点包括：

1. **强制性阶段门禁**：确保前置条件满足
2. **结构化模板**：标准化输出格式和质量
3. **质量验证机制**：防止低质量交付
4. **零假设原则**：确保不确定性被显式暴露
5. **任务依赖管理**：优化执行效率

通过这套指令流程架构，PowerBy-skills能够将松散的对话式开发流程转化为结构化的开发流水线，提高开发效率和交付质量。
